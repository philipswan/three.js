<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - launch trajectory editor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #f0f0f0;
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - geometry - catmull spline editor
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { TransformControls } from 'three/addons/controls/TransformControls.js';
			import TWEEN from 'three/addons/libs/tween.module.js';
			import { launchVehicleModel } from './jsm/objects/rocket.js'

			let container;
			let camera, scene, renderer;
			let orbitControls;
			let logZoomRate = -2

			const splineHandleObjects = [];
			let splinePointsLength = 4;
			let ringToPlanetRotation = new THREE.Quaternion()

			let radiusOfPlanet = 6378100 // m   using radius of Earth for now
			let nearClippingPlane = 0.001 * radiusOfPlanet
			let farClippingPlane = 10 * radiusOfPlanet
			let planetCoordSys
			let planetMeshes
			let tetheredRingRefCoordSys

			const positions = [];
			const point = new THREE.Vector3();

			const clock = new THREE.Clock();
			const raycaster = new THREE.Raycaster();
			const pointer = new THREE.Vector2();
			const onUpPosition = new THREE.Vector2();
			const onDownPosition = new THREE.Vector2();
			const mouse = {
				x: undefined,
				y: undefined
			}

			const splineHandleGeometry = new THREE.BoxGeometry( 2000, 2000, 2000 );
			let transformControl;

			const ARC_SEGMENTS = 200;

			const splines = {};

			const params = {
				uniform: true,
				tension: 0.5,
				logZoomRate: -2,
				elevationFactor: 1,
				logRocketScale: 4,
				massDriverAcceleration: 50,
				rampUpwardAcceleration: 50,
				massDriverAltitude: 0,
				launcherRampExitAltitude: 4169.4,
				sunlightIntensity: 2,
				ambientLightIntensity: 0.5,
				centripetal: true,
				chordal: true,
				addPoint: addPoint,
				removePoint: removePoint,
				exportSpline: exportSpline
			};

			const GRAPH_WIDTH = 600;
			const GRAPH_HEIGHT = 300;
			export class XYChart {
				constructor (scene) {
					this.scene = scene
					this.chartGroup = new THREE.Group()
					this.scene.add(this.chartGroup)
					this.width = GRAPH_WIDTH
					this.height = GRAPH_HEIGHT
					this.curveInfo = []
				}
				// More TBD
			}

			class referenceFrame {
				constructor(numWedges) {
					this.timeSinceStart = 0
					this.startWedgeIndex = -1
					this.finishWedgeIndex = -1
					this.prevStartWedgeIndex = -1
					this.prevFinishWedgeIndex = -1
					const makePlaceHolderEntry = () => ({
						'virtualLaunchVehicles': [],
					})
					this.wedges = new Array(numWedges).fill().map( makePlaceHolderEntry )
				}
			}

			class virtualLaunchVehicle {
				constructor(timeLaunched, unallocatedModelsArray) {
					// The virtual vehicle has a position along the launch trajectory curve.
					// 0 represents the beginning of the mass driver, 1 represents 't==durationOfLaunchTrajectory'
					this.timeLaunched = timeLaunched
					this.unallocatedModels = unallocatedModelsArray
				}

				// The following properties are common to all virtual vehicles...
				static launchTrajectoryCurve
				static durationOfLaunchTrajectory
				//static launchVehicleRelativePosition_r = []
				//static launchVehicleRelativePosition_y = []
				static currentEquivalentLatitude
				static isVisible
				static isDynamic
				static hasChanged

				static update(dParamWithUnits, launchTrajectoryCurve, durationOfLaunchTrajectory, timeWithinMassDriver, curveUpTime, timeWithinEvacuatedTube) {
					virtualLaunchVehicle.launchTrajectoryCurve = launchTrajectoryCurve
					virtualLaunchVehicle.durationOfLaunchTrajectory = durationOfLaunchTrajectory
					virtualLaunchVehicle.timeInsideLaunchSystem = timeWithinMassDriver + curveUpTime + timeWithinEvacuatedTube
					//const outwardOffset = dParamWithUnits['launcherOutwardOffset'].value
					//const upwardOffset = dParamWithUnits['launcherUpwardOffset'].value
					//virtualLaunchVehicle.launchVehicleRelativePosition_r = tram.offset_r(outwardOffset, upwardOffset, crv.currentEquivalentLatitude)
					//virtualLaunchVehicle.launchVehicleRelativePosition_y  = tram.offset_y(outwardOffset, upwardOffset, crv.currentEquivalentLatitude)
					//virtualLaunchVehicle.currentEquivalentLatitude = crv.currentEquivalentLatitude
					virtualLaunchVehicle.isVisible = dParamWithUnits['showLaunchVehicles'].value
					virtualLaunchVehicle.showLaunchVehiclePointLight = dParamWithUnits['showLaunchVehiclePointLight'].value
					virtualLaunchVehicle.slowDownPassageOfTime = dParamWithUnits['launcherSlowDownPassageOfTime'].value
					virtualLaunchVehicle.isDynamic =  true
					virtualLaunchVehicle.hasChanged = true
					//virtualLaunchVehicle.ringSouthernMostPosition = ringSouthernMostPosition
				}

				placeAndOrientModel(om, refFrame) {
					const deltaT = refFrame.timeSinceStart * virtualLaunchVehicle.slowDownPassageOfTime - this.timeLaunched
					const modelsCurvePosition = deltaT / virtualLaunchVehicle.durationOfLaunchTrajectory
					
					if (modelsCurvePosition==='undefined' || (modelsCurvePosition<0)) {
						console.log("error!!!")
					}
					// ToDo: we should be removing the model before we get to the point where it has travelled beyond the end of the launch tragectory
					else if (modelsCurvePosition<=1) {
						const pointOnLaunchTrajectoryCurve = virtualLaunchVehicle.launchTrajectoryCurve.getPoint(modelsCurvePosition)
						const tangentToLaunchTrajectoryCurve = virtualLaunchVehicle.launchTrajectoryCurve.getTangent(modelsCurvePosition)
						const normalToLaunchTrajectoryCurve = pointOnLaunchTrajectoryCurve.clone().normalize() // This is a bit of a hack - it assumes the curve hugs the surface of the planet

						om.position.set(
							pointOnLaunchTrajectoryCurve.x,
							pointOnLaunchTrajectoryCurve.y,
							pointOnLaunchTrajectoryCurve.z)
						const straightUpVector = new THREE.Vector3(0, 1, 0)
						const q = new THREE.Quaternion().setFromUnitVectors(straightUpVector, tangentToLaunchTrajectoryCurve)
						om.rotation.setFromQuaternion(q)
						om.rotateY(-om.getWorldDirection(new THREE.Vector3()).angleTo(normalToLaunchTrajectoryCurve))

						om.visible = virtualLaunchVehicle.isVisible

						// Turn on the flame at the exit of the launch tube
						// ToDo: Using hard coded indicies for parts of the model is not good for code maintainability - improve this but without degrading performance.
						if (deltaT > virtualLaunchVehicle.timeInsideLaunchSystem) {
							om.children[1].visible = true
						}
						else {
							om.children[1].visible = false
						}
						om.children[2].visible = virtualLaunchVehicle.showLaunchVehiclePointLight
						om.matrixValid = false
					}
					// ToDo: we should be removing the model before we get to the point where it has travelled beyond the end of the launch tragectory
					else {
						om.visible = false
					}
				}
			}

			class launcher {
				constructor(dParamWithUnits, planetCoordSys, radiusOfPlanet, xyChart, clock) {
					this.const_G = 0.0000000000667408;
					this.clock = clock
					this.versionNumber = 0

					// Possible User defined (e.g. if user changes the planet)
					this.const_g = 9.8;
					this.const_M = 5.9722E+24;
					this.mu = this.const_G * this.const_M;
					this.R_Earth = 6371000;
					this.xyChart = xyChart

					// User defined parameters
					this.MPayload = 60000;
					this.Alt_LEO = 400000;
					this.Alt_Perigee = 48000;
					this.WholesaleElectricityCost = 0.05;
					this.LiquidHydrogenCostPerGallon = 0.98;
					this.LiquidOxygenCostPerGallon = 0.67;
					this.MassOfOneGallonOfLiquidHydrogen = 0.2679; // kg / Gallon
					this.MassOfOneGallonOfLiquidOxygen = 4.322; // kg / Gallon
					this.MassOfHydrogen = 384071 * this.MassOfOneGallonOfLiquidHydrogen;
					this.MassOfOxygen = 141750 * this.MassOfOneGallonOfLiquidOxygen;
					this.FuelCostPerkg = (this.MassOfHydrogen / this.MassOfOneGallonOfLiquidHydrogen * this.LiquidHydrogenCostPerGallon + this.MassOfOxygen / this.MassOfOneGallonOfLiquidOxygen * this.LiquidOxygenCostPerGallon) / (this.MassOfHydrogen + this.MassOfOxygen);
					this.EstimatedCostToFuelSLSToLEO = ((979452 - 85270) + (30710 - 3490)) * this.FuelCostPerkg / 95000;
					this.RocketsSpecificImpulse = 452; // RS-25
					this.RocketEnginesMass = 3527; // RS-25
					this.LauncherEfficiency = 0.75;
					this.MaxGees = 3;
					this.LauncherAltitude = 32000;
					this.Alt_EvacuatedTube = 32000;
					this.VehicleRadius = 2.4/2; // Assuming a cylindrically shaped vehicle the diameter of an RS-25 Rocket Engine
					this.CoefficientOfDrag = 0.4;

					this.scene = planetCoordSys

					this.timeWithinMassDriver = dParamWithUnits['launcherMassDriverExitVelocity'].value / dParamWithUnits['launcherMassDriverForwardAcceleration'].value
				
					const redMaterial = new THREE.MeshLambertMaterial({color: 0xdf4040})
					const greenMaterial = new THREE.MeshLambertMaterial({color: 0x40df40})
					const blueMaterial = new THREE.MeshLambertMaterial({color: 0x4040df})
					this.LaunchTrajectoryMarker1 = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 16), redMaterial)
					const LaunchTrajectoryMarkerSize = dParamWithUnits['launcherMarkerRadius'].value
					this.LaunchTrajectoryMarker1.scale.set(LaunchTrajectoryMarkerSize, LaunchTrajectoryMarkerSize, LaunchTrajectoryMarkerSize)
					this.LaunchTrajectoryMarker2 = this.LaunchTrajectoryMarker1.clone()
					this.LaunchTrajectoryMarker2.material = greenMaterial
					this.LaunchTrajectoryMarker3 = this.LaunchTrajectoryMarker1.clone()
					this.LaunchTrajectoryMarker3.material = blueMaterial
					this.LaunchTrajectoryMarker4 = this.LaunchTrajectoryMarker1.clone()
					planetCoordSys.add(this.LaunchTrajectoryMarker1)
					planetCoordSys.add(this.LaunchTrajectoryMarker2)
					planetCoordSys.add(this.LaunchTrajectoryMarker3)
					planetCoordSys.add(this.LaunchTrajectoryMarker4)
					this.LaunchTrajectoryMarker1.visible = dParamWithUnits['showLaunchTrajectory'].value
					this.LaunchTrajectoryMarker2.visible = dParamWithUnits['showLaunchTrajectory'].value
					this.LaunchTrajectoryMarker3.visible = dParamWithUnits['showLaunchTrajectory'].value
					this.LaunchTrajectoryMarker4.visible = dParamWithUnits['showLaunchTrajectory'].value

					this.launchTrajectoryCurve = null
					this.launchTrajectoryMesh = null

					this.numWedges = 1
					this.unallocatedLaunchVehicleModels = []
					this.unallocatedLaunchSledModels = []
					this.refFrames = [
						// For vehicles cruising at a steady speed...
						new referenceFrame(this.numWedges)
					]
					this.actionFlags = new Array(this.numWedges).fill(0)
					this.perfOptimizedThreeJS = dParamWithUnits['perfOptimizedThreeJS'].value ? 1 : 0

					this.updateTrajectoryCurves(dParamWithUnits, planetCoordSys, radiusOfPlanet)
					// Next, create all of the virtual objects that will be placed along the launch trajectory curve
					
					// Add the virtual launch sleds and launch vehicles
					const tInc = dParamWithUnits['launchVehicleSpacingInSeconds'].value
					let t, n, wedgeIndex
					// Put all of the virtual launch vehicles into the same wedge for now
					wedgeIndex = 0
					const refFrame = this.refFrames[0]
					// Hack - remove "&& (n<150)"
					for (t = -.02, n = 0; (t<this.durationOfLaunchTrajectory) && (n<150); t += tInc, n++) {
						refFrame.wedges[wedgeIndex]['virtualLaunchVehicles'].push(new virtualLaunchVehicle(-t, this.unallocatedLaunchVehicleModels))
					}

					// Create and add the launch sleds
					//const launchSledMesh = new launchSledModel(dParamWithUnits, this.massDriverSuperCurve, this.launcherMassDriverLength, this.massDriverScrewSegments, this.massDriverScrewTexture)
					// n = dParamWithUnits['launchVehicleNumModels'].value
					//addLaunchSleds(launchSledMesh, this.scene, this.unallocatedLaunchSledModels, 'launchSled', 1, n, this.perfOptimizedThreeJS)

					function addLaunchSleds(object, myScene, unallocatedModelsList, objName, scaleFactor, n, perfOptimizedThreeJS) {
						object.updateMatrixWorld()
						object.visible = false
						object.name = objName
						object.traverse(child => {
							if (child!==object) {
								child.name = objName+'_'+child.name
							}
						})
						if (perfOptimizedThreeJS) object.children.forEach(child => child.freeze())
						object.scale.set(scaleFactor, scaleFactor, scaleFactor)
						for (let i=0; i<n; i++) {
							const tempModel = object.clone()
							myScene.add(tempModel)
							unallocatedModelsList.push(tempModel)
						}
					}

					// Create and add the launch vechicle models
					const launchVehicleMesh = new launchVehicleModel(dParamWithUnits)

					// n = dParamWithUnits['launchVehicleNumModels'].value
					addLaunchVehicles(launchVehicleMesh, this.scene, this.unallocatedLaunchVehicleModels, 'launchVehicle', 1, n, this.perfOptimizedThreeJS)

					function addLaunchVehicles(object, myScene, unallocatedModelsList, objName, scaleFactor, n, perfOptimizedThreeJS) {
						object.updateMatrixWorld()
						object.visible = false
						object.name = objName
						object.traverse(child => {
							if (child!==object) {
							child.name = objName+'_'+child.name
							}
						})
						if (perfOptimizedThreeJS) object.children.forEach(child => child.freeze())
						object.scale.set(scaleFactor, scaleFactor, scaleFactor)
						for (let i=0; i<n; i++) {
							const tempModel = object.clone()
							myScene.add(tempModel)
							unallocatedModelsList.push(tempModel)
						}
					}

					this.update(dParamWithUnits)
				}

				update(dParamWithUnits) {
					this.versionNumber++
					//virtualMassDriverTube.update(dParamWithUnits, this.massDriverSuperCurve, this.versionNumber)
					//virtualMassDriverRail.update(dParamWithUnits, this.massDriverSuperCurve, this.versionNumber)
					//virtualMassDriverBracket.update(dParamWithUnits, this.massDriverSuperCurve, this.versionNumber)
					//virtualMassDriverScrew.update(dParamWithUnits, this.massDriverSuperCurve, this.versionNumber)
					//virtualEvacuatedTube.update(dParamWithUnits, this.evacuatedTubeCurve)
					//virtualLaunchSled.update(dParamWithUnits, this.massDriverSuperCurve, this.launcherMassDriverLength, this.scene)
					virtualLaunchVehicle.update(dParamWithUnits, this.launchTrajectoryCurve, this.durationOfLaunchTrajectory, this.timeWithinMassDriver, this.curveUpTime, this.timeWithinEvacuatedTube)
					this.animateLaunchVehicles = dParamWithUnits['animateLaunchVehicles'].value ? 1 : 0
					//this.animateLaunchSleds = dParamWithUnits['animateLaunchSleds'].value ? 1 : 0

					const wedgeIndex = 0
					const refFrame = this.refFrames[0]

					this.LaunchTrajectoryMarker1.visible = dParamWithUnits['showLaunchTrajectory'].value
					this.LaunchTrajectoryMarker2.visible = dParamWithUnits['showLaunchTrajectory'].value
					this.LaunchTrajectoryMarker3.visible = dParamWithUnits['showLaunchTrajectory'].value
					this.LaunchTrajectoryMarker4.visible = dParamWithUnits['showLaunchTrajectory'].value
					this.xyChart.chartGroup.visible = dParamWithUnits['showXYChart'].value
				}
				
				updateTrajectoryCurves(
					dParamWithUnits,
					planetCoordSys,
					radiusOfPlanet) {
					// The goal is to position the suspended portion of the evacuated launch tube under the tethered ring's tethers. The portion of the launch tube that contains the mass driver will be on the planet's surface.
					// Let's start by defining the sothern most point on the ring as the end of the mass driver. Then we can create a curve that initially follows the surface of the Earth and then, from the end of the mass driver,
					// follows a hyperbolic trajectory away from the earth.

					// console.print: console.log without filename/line number
					console.print = function (...args) {
						queueMicrotask (console.log.bind (console, ...args));
					}

					// ***************************************************************
					// Design the mass driver
					// ***************************************************************

					let forwardAcceleration
					let upwardAcceleration
					let timeNow = this.clock.getElapsedTime()
					function gotStuckCheck(clock, timeNow, t, msg) {
						if (t%2==0) {
							if (timeNow + 2 < clock.getElapsedTime()) {
								console.log('Stuck in ', msg)
								return true
							}
							else {
								return false
							}
						}
						else {
							return false
						}
					}

					const launcherMassDriverInitialVelocity = dParamWithUnits['launcherMassDriverInitialVelocity'].value
					const launcherMassDriverExitVelocity = dParamWithUnits['launcherMassDriverExitVelocity'].value
					const launcherMassDriverAltitude = dParamWithUnits['launcherMassDriverAltitude'].value
					const launcherEvacuatedTubeExitAltitude = dParamWithUnits['launcherEvacuatedTubeExitAltitude'].value

					forwardAcceleration = dParamWithUnits['launcherMassDriverForwardAcceleration'].value

					// Determine the time in the mass driver from acceleration, initial velocity, and final velocity
					// vf = v0 + at, therefore t = (vf-v0)/a
					const launcherMassDriverAccelerationTime = (launcherMassDriverExitVelocity - launcherMassDriverInitialVelocity) / forwardAcceleration
					this.timeWithinMassDriver = launcherMassDriverAccelerationTime

					const launcherMassDriverLength = launcherMassDriverInitialVelocity * launcherMassDriverAccelerationTime + 0.5 * forwardAcceleration * launcherMassDriverAccelerationTime**2
					this.launcherMassDriverLength = launcherMassDriverLength

					// ***************************************************************
					// Design the ramp. The ramp is positioned at the end of the mass driver to divert the vehicle's trajectory skyward.
					// ***************************************************************
					// Clamp the altitude of the ramp to be between the altitude of the launcher and the altitude of the main ring.
					const launcherRampExitAltitude = Math.max(launcherMassDriverAltitude+1, Math.min(dParamWithUnits['launcherRampExitAltitude'].value, launcherEvacuatedTubeExitAltitude))
					const launcherRampEndLatitudeDegreesN = dParamWithUnits['launcherRampEndLatitudeDegreesN'].value
					const launcherRampEndLonitudeDegreesE = dParamWithUnits['launcherRampEndLonitudeDegreesE'].value

					const evacuatedTubeEntrancePosition = new THREE.Vector3().setFromSphericalCoords(
						radiusOfPlanet + launcherRampExitAltitude,
						Math.PI/2 - launcherRampEndLatitudeDegreesN*Math.PI/180, // ° N
						launcherRampEndLonitudeDegreesE*Math.PI/180, // ° W,
					);
					const evacuatedTubeExitPosition = evacuatedTubeEntrancePosition.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.01).multiplyScalar((radiusOfPlanet + 2*launcherRampExitAltitude) / (radiusOfPlanet + launcherRampExitAltitude))

					const launcherMassDriverUpwardAcceleration = dParamWithUnits['launcherMassDriverUpwardAcceleration'].value
					const accelerationOfGravity = 9.8 // m/s2 // ToDo: Should make this a function of the selected planet
					const allowableUpwardTurningRadius = launcherMassDriverExitVelocity**2 / (launcherMassDriverUpwardAcceleration - accelerationOfGravity)

					// Make a triangle ABC where A is the center of the planet, B is the end of the ramp, and C is the center of the circle that defines the allowable turning radius
					const triangleSideAB = radiusOfPlanet + launcherRampExitAltitude
					const triangleSideAC = radiusOfPlanet + launcherMassDriverAltitude + allowableUpwardTurningRadius
					const triangleSideBC = allowableUpwardTurningRadius
					// Use law of cosines to find the angles at C and B
					const angleACB = Math.acos((triangleSideAC**2 + triangleSideBC**2 - triangleSideAB**2) / (2*triangleSideAC*triangleSideBC))
					const angleABC = Math.acos((triangleSideAB**2 + triangleSideBC**2 - triangleSideAC**2) / (2*triangleSideAB*triangleSideBC))
					const angleBAC = Math.PI - angleACB - angleABC
					const upwardAngleAtEndOfRamp = Math.PI - angleABC

					const rampBaseLength = angleBAC * (radiusOfPlanet + launcherMassDriverAltitude) // This is the length along the base of the ramp, measured at ground level, assuming the altitude of the ground is the same as the altitude of the launcher

					// console.log('triangleSideAB', triangleSideAB)
					// console.log('triangleSideAC', triangleSideAC)
					// console.log('triangleSideBC', triangleSideBC)
					// console.log('angleACB', angleACB, angleACB*180/Math.PI)
					// console.log('upwardAngleAtEndOfRamp', upwardAngleAtEndOfRamp, upwardAngleAtEndOfRamp*180/Math.PI)

					this.launcherRampLength = angleACB * allowableUpwardTurningRadius
					this.curveUpTime = this.launcherRampLength / launcherMassDriverExitVelocity // ToDo: This is inaccurate as it does not take into account the loss of speed due to coasting up the ramp.

					// Let's define the end of the ramp as the launcher's exit position, since from that point on the vehicles will either be coasting or accelerating under their own power.
					// Also, it's a position that we can stick at the top of a mountain ridge and from there adjust parameters like launcher accelleration, etc.

					// ***************************************************************
					// Now design the evacuated tube that the vehicles will travel within from the end of the ramp to the altitude of the main ring.  
					// ***************************************************************

					const R0 = new THREE.Vector3(radiusOfPlanet + launcherRampExitAltitude, 0, 0)  // This is the vehicle's altitude (measured from the plantet's center) and downrange position at the exit of the launcher
					
					// for (let launcherMassDriverExitVelocity = 100; launcherMassDriverExitVelocity<8000; launcherMassDriverExitVelocity+=100) {
					//   const V0 = new THREE.Vector3(launcherMassDriverExitVelocity * Math.sin(upwardAngleAtEndOfRamp), launcherMassDriverExitVelocity * Math.cos(upwardAngleAtEndOfRamp), 0) // This is the vehicle's velocity vector at the exit of the launcher
					//   const coe = this.orbitalElementsFromStateVector(R0, V0)
					//   const c = coe.semimajorAxis * coe.eccentricity
					//   const apogeeDistance = coe.semimajorAxis + c
					//   const speedAtApogee = Math.sqrt(this.mu * (2 / apogeeDistance - 1 / coe.semimajorAxis))
					//   const speedOfCircularizedOrbit = Math.sqrt(this.mu / apogeeDistance)
					//   const deltaVNeededToCircularizeOrbit = speedOfCircularizedOrbit - speedAtApogee
					//   const launchVehicleRocketExhaustVelocity = dParamWithUnits['launchVehicleRocketExhaustVelocity'].value
					//   const m0Overmf = Math.exp(deltaVNeededToCircularizeOrbit / launchVehicleRocketExhaustVelocity)
					//   console.print(launcherMassDriverExitVelocity, Math.round(apogeeDistance - radiusOfPlanet), Math.round(deltaVNeededToCircularizeOrbit), Math.round(m0Overmf * 100)/100)
					// }

					const V0 = new THREE.Vector3(launcherMassDriverExitVelocity * Math.sin(upwardAngleAtEndOfRamp), launcherMassDriverExitVelocity * Math.cos(upwardAngleAtEndOfRamp), 0) // This is the vehicle's velocity vector at the exit of the launcher
					const coe = this.orbitalElementsFromStateVector(R0, V0)
					const c = coe.semimajorAxis * coe.eccentricity
					const apogeeDistance = coe.semimajorAxis + c
					const speedAtApogee = Math.sqrt(this.mu * (2 / apogeeDistance - 1 / coe.semimajorAxis))
					const speedOfCircularizedOrbit = Math.sqrt(this.mu / apogeeDistance)
					const deltaVNeededToCircularizeOrbit = speedOfCircularizedOrbit - speedAtApogee
					const launchVehicleRocketExhaustVelocity = dParamWithUnits['launchVehicleRocketExhaustVelocity'].value
					const m0Overmf = Math.exp(deltaVNeededToCircularizeOrbit / launchVehicleRocketExhaustVelocity)
					//console.log(coe)
					// console.log('speedAtApogee', speedAtApogee)
					// console.log('apogeeAltitude', apogeeDistance - radiusOfPlanet)
					// console.log('deltaVNeededToCircularizeOrbit', deltaVNeededToCircularizeOrbit)
					// console.log('m0Overmf', m0Overmf) // This is the initial mass of the fueled vehicle divided by the mass of the vehicle after it's rocket engine has burned out and it has circularized it's orbit.

					// Better V0 calculation - we need to take into account the rotation of the planet...
					//const V0 = new THREE.Vector2(launcherMassDriverExitVelocity * Math.sin(upwardAngleAtEndOfRamp), launcherMassDriverExitVelocity * Math.cos(upwardAngleAtEndOfRamp)) // This is the vehicle's velocity vector at the exit of the launcher
					//console.log(R0, V0)

					// We want to find the downrange distance where the vehicle's altitude is equal to the desired suspended evacuated tube exit altitude (or the ground, if it's not going fast enough).
					// We will solve for this iteratively, although there's probably a better way...
					// We will also assume that the vehicle will not fire it's rocket engine while it is within the evacuated tube.
					let t = 0
					let tStep = .1 // second
					let RV, distSquared
					let converging = true
					let lastDifference = -1

					const planetRadiusSquared = radiusOfPlanet**2
					const ringDistSquared = (radiusOfPlanet + launcherEvacuatedTubeExitAltitude)**2
					//console.log('Calculating downrange distance from end of ramp to a point on the hyperbolic trajectory at the ring\'s altitude')
					for (t = 0; (Math.abs(tStep)>0.01) && t<dParamWithUnits['launcherCoastTime'].value && converging; t+=tStep) {
						RV = this.RV_from_R0V0andt(R0.x, R0.y, V0.x, V0.y, t)
						distSquared = RV.R.x**2 + RV.R.y**2
						const withinBoundaries = (distSquared < ringDistSquared) && (distSquared > planetRadiusSquared) 
						if (withinBoundaries ^ (tStep>0)) {
							tStep = -tStep/2
						}
						else {
							// Check that we're converging towards (as opposed to diverging from) a solution
							const difference = Math.abs(distSquared - ringDistSquared)
							if ((lastDifference !== -1) && (difference > lastDifference)) {
								converging = false
							}
							else {
								lastDifference = difference
							}
						}
						if (gotStuckCheck(this.clock, timeNow, t, 'the downrange distance calculation')) break
					}
					if (!converging) {
						console.log('Warning: The downrange distance calculation did not converge')
					}
					//console.log('done')
					this.timeWithinEvacuatedTube = t

					const evacuatedTubeDownrangeAngle = Math.atan2(RV.R.y, RV.R.x)  // This is the angle subtending the end of the ramp, center of the earth, and the end of the evacuated tube

					// ***************************************************************
					// Next we need to place the end of the ramp and the end of the evacuated tube at locations that are directly under the ring, 
					// so that the lightweight evacuated tube that the launched vehicles will inititially coast through can be suspended from the ring.

					// Generate an axis of rotation for define the curvatures of the mass driver and the ramp
					this.axisOfRotation = new THREE.Vector3().crossVectors(evacuatedTubeEntrancePosition, evacuatedTubeExitPosition.clone().sub(evacuatedTubeEntrancePosition)).normalize()

					// Calculate a vector that points to the exit of the mass driver (and the entrance to the ramp)
					const massDriverExitPosition = evacuatedTubeEntrancePosition.clone().applyAxisAngle(this.axisOfRotation, -rampBaseLength / (radiusOfPlanet + launcherMassDriverAltitude))
					massDriverExitPosition.multiplyScalar((radiusOfPlanet + launcherMassDriverAltitude) / (radiusOfPlanet + launcherRampExitAltitude))

					// Position markers at the end of the mass driver and at entrance and exit positions of the evacuated tube
					this.LaunchTrajectoryMarker1.position.copy(massDriverExitPosition)
					this.LaunchTrajectoryMarker2.position.copy(evacuatedTubeEntrancePosition)
					this.LaunchTrajectoryMarker3.position.copy(evacuatedTubeExitPosition)

					// ***************************************************************
					// Next we need to capture some curves and data sets for plotting
					// ***************************************************************

					const launchTrajectoryCurveControlPoints = []
					const massDriverCurveControlPoints = []
					const evacuatedTubeCurveControlPoints = []

					const altitudeVesusTimeData = []
					const speedVersusTimeData = []
					const downrangeDistanceVersusTimeData = []
					const forwardAccelerationVersusTimeData = []
					const lateralAccelerationVersusTimeData = []
					const aerodynamicDragVersusTimeData = []
					const totalMassVerusTimeData = []

					const t1 = this.timeWithinMassDriver
					const t2 = t1 + this.curveUpTime
					const t3 = t2 + this.timeWithinEvacuatedTube
					const t4 = t3 + dParamWithUnits['launcherCoastTime'].value

					let vehiclePosition
					let vehicleAirSpeed
					let distanceTravelled
					let altitude

					// Prep the vehicle's initial conditions
					const mVehicle = dParamWithUnits['launchVehicleEmptyMass'].value
					const mPayload = dParamWithUnits['launchVehiclePayloadMass'].value
					let mPropellant = dParamWithUnits['launchVehiclePropellantMass'].value
					let m0 = mVehicle + mPayload + mPropellant // mass of vehicle, payload, and propellant

					t = 0
					tStep = .1 // second

					// ***************************************************************
					// Create the part of the trajectory where the vehicle is within mass driver near the planet's surface
					// ***************************************************************
					this.massDriverSuperCurve = new THREE.CircleSuperCurve3(new THREE.Vector3(0, 0, 0), this.axisOfRotation, massDriverExitPosition, -launcherMassDriverLength)
					function tTos(t, launcherMassDriverInitialVelocity, forwardAcceleration) {
						return launcherMassDriverInitialVelocity + forwardAcceleration * t  // 1/2 at^2
					}
					function tTod(t, launcherMassDriverInitialVelocity, forwardAcceleration) {
						return launcherMassDriverInitialVelocity * t + 0.5 * forwardAcceleration * t * t  // 1/2 at^2
					}
					this.massDriverSuperCurve.addtTodConvertor(tTod)

					// Start the launch trajectory curve at the beginning of the mass driver.
					//console.log('Creating mass driver part of trajectory.')
					upwardAcceleration = 0   // This does not include the acceleration of gravity from the planet
					altitude = launcherMassDriverAltitude

					for (t = 0; t < this.timeWithinMassDriver; t += tStep) {
						vehicleAirSpeed = tTos(t, launcherMassDriverInitialVelocity, forwardAcceleration)
						distanceTravelled = tTod(t, launcherMassDriverInitialVelocity, forwardAcceleration)
						// Rotate the massDriverExitPosition around the axisOfRotation using the angle derived from the distance travelled
						vehiclePosition = massDriverExitPosition.clone().applyAxisAngle(this.axisOfRotation, (distanceTravelled - launcherMassDriverLength) / (radiusOfPlanet + launcherMassDriverAltitude))
						//console.log('old angle', (distanceTravelled - launcherMassDriverLength) / (radiusOfPlanet + launcherMassDriverAltitude))
						const vp2 = this.massDriverSuperCurve.getPointAt(distanceTravelled/launcherMassDriverLength)
						if (t==0) {
							this.startOfMassDriverPosition = vehiclePosition.clone()
						}
						launchTrajectoryCurveControlPoints.push(vehiclePosition)
						altitudeVesusTimeData.push(new THREE.Vector3(t, altitude, 0))
						downrangeDistanceVersusTimeData.push(new THREE.Vector3(t, distanceTravelled, 0))
						speedVersusTimeData.push(new THREE.Vector3(t, vehicleAirSpeed, 0))
						forwardAccelerationVersusTimeData.push(new THREE.Vector3(t, forwardAcceleration, 0))
						lateralAccelerationVersusTimeData.push(new THREE.Vector3(t, 0, 0))
						aerodynamicDragVersusTimeData.push(new THREE.Vector3(t, 0, 0)) // ToDo: Should make this a function of the level of vacuum and type of gas inside the mass drivers evacuated tube
						totalMassVerusTimeData.push(new THREE.Vector3(t, m0, 0))
					}
					//console.log('done')

					// ***************************************************************
					// Create the part of the trajectory where the vehicle is travelling along the upward curving ramp
					// ***************************************************************
					const l1 = massDriverExitPosition.length()   // Distance from the center of the planet to the end of the mass driver
					const v1 = massDriverExitPosition.clone().multiplyScalar((allowableUpwardTurningRadius + l1) / l1)  // Points to the center of the circle that defines the ramp's curve
					const v2 = massDriverExitPosition.clone().multiplyScalar(-allowableUpwardTurningRadius / l1)     // A vector from the center of the circle that defines the ramp back to the mass driver's exit position.
					//const pivotPoint = massDriverExitPosition.clone().multiplyScalar((l1+allowableUpwardTurningRadius)/l1)
					this.LaunchTrajectoryMarker4.position.copy(v1)

					forwardAcceleration = 0
					upwardAcceleration = launcherMassDriverUpwardAcceleration

					//console.log('Creating ramp part of trajectory.')
					for (; t<Math.min(t2, 10000); t+=tStep) {   // Hack - Min function added to prevent endless loop in case of bug
						// Rotate the vehicle position vector around center of the circle that defines the shape of the ramp
						const distanceTravelledAlongRamp = (t - this.timeWithinMassDriver) * launcherMassDriverExitVelocity   // ToDo: This assumes that somehow we maintain speed on the ramp, but really need a better formula here.
						vehiclePosition = v1.clone().add(v2.clone().applyAxisAngle(this.axisOfRotation, -distanceTravelledAlongRamp / allowableUpwardTurningRadius))
						vehicleAirSpeed = launcherMassDriverExitVelocity  // ToDo: This assumes that somehow we maintain speed on the ramp, but really need a better formula here.
						altitude = vehiclePosition.length() - radiusOfPlanet
						const downrangeAngle = massDriverExitPosition.angleTo(vehiclePosition)
						const downrangeDistance = launcherMassDriverLength + downrangeAngle * (radiusOfPlanet + launcherMassDriverAltitude)
						launchTrajectoryCurveControlPoints.push(vehiclePosition)
						altitudeVesusTimeData.push(new THREE.Vector3(t, altitude, 0))
						downrangeDistanceVersusTimeData.push(new THREE.Vector3(t, downrangeDistance, 0))
						speedVersusTimeData.push(new THREE.Vector3(t, vehicleAirSpeed, 0))
						forwardAccelerationVersusTimeData.push(new THREE.Vector3(t, forwardAcceleration, 0))
						lateralAccelerationVersusTimeData.push(new THREE.Vector3(t, upwardAcceleration, 0))
						aerodynamicDragVersusTimeData.push(new THREE.Vector3(t, 0, 0)) // ToDo: Should make this a function of the level of vacuum and type of gas inside the mass drivers evacuated tube
						totalMassVerusTimeData.push(new THREE.Vector3(t, m0, 0))
					}
					//console.log('done')

					vehiclePosition = v1.clone().add(v2.clone().applyAxisAngle(this.axisOfRotation, -angleACB))
					//this.LaunchTrajectoryMarker2.position.copy(vehiclePosition)
					const downrangeAngle = massDriverExitPosition.angleTo(vehiclePosition)
					const downrangeDistanceTravelledOnRamp = downrangeAngle * radiusOfPlanet
					distanceTravelled += angleACB * allowableUpwardTurningRadius

					// ***************************************************************
					// Create the part of the trajectory where the vehicle coasts on an eliptical or hyperbolic trajectory both within the evacuated tube and beyond
					// ***************************************************************
					// We'll need to generate some parameters to help us calculate the aerodynamic drage on the vehicle while it's travvelling through the raqrified uppoer atmosphere 
					const launchVehicleRadius = dParamWithUnits['launchVehicleRadius'].value
					const launchVehicleBodyLength = dParamWithUnits['launchVehicleBodyLength'].value
					const launchVehicleNoseConeLength = dParamWithUnits['launchVehicleNoseConeLength'].value
					const noseConeAngle = Math.atan2(launchVehicleRadius, launchVehicleNoseConeLength)
					
					let aerodynamicDrag
					let tStepState = 0
					let lastR = R0
					let distanceTravelledWithinEvacuatedTube = 0
					let distanceTravelledOutsideLaunchSystem = 0
					let warningAlreadyGiven = false
					const partialStep = 0  // Will be calcualte in the loop
					const tStep2 = [tStep, partialStep, partialStep, tStep]
					const l2 = evacuatedTubeEntrancePosition.length()
					//console.log('Creating hyprebolic part of trajectory.')
					for (; t < t4; t += tStep2[tStepState]) {
						const t5 = t - t2
						const RV = this.RV_from_R0V0andt(R0.x, R0.y, V0.x, V0.y, t5)
						const downrangeAngle = Math.atan2(RV.R.y, RV.R.x)
						// Calculate the vehicle's position relative to where R0 and V0 were when the vehicle was at R0.
						vehiclePosition = evacuatedTubeEntrancePosition.clone().applyAxisAngle(this.axisOfRotation, downrangeAngle).multiplyScalar(RV.R.length() / l2)
						vehicleAirSpeed = Math.sqrt(RV.V.y**2 + RV.V.x**2) // ToDo: The speed due to the planet's rotation needs to be calculated and factored in
						altitude = Math.sqrt(RV.R.y**2 + RV.R.x**2) - radiusOfPlanet
						const deltaDistanceTravelled = Math.sqrt((RV.R.x-lastR.x)**2 + (RV.R.y-lastR.y)**2) // ToDo: Would be better to find the equation for distance traveled along a hyperbolic path versus time.
						const downrangeDistance = launcherMassDriverLength + rampBaseLength + downrangeAngle * (radiusOfPlanet + launcherMassDriverAltitude)
						if (t<t3) {
							aerodynamicDrag = 0
							distanceTravelledWithinEvacuatedTube += deltaDistanceTravelled
						}
						else {
							distanceTravelledOutsideLaunchSystem += deltaDistanceTravelled
							aerodynamicDrag = this.GetAerodynamicDrag_ChatGPT(altitude, vehicleAirSpeed, noseConeAngle, launchVehicleRadius, launchVehicleBodyLength)
						}
						const fuelFlowRate = aerodynamicDrag / launchVehicleRocketExhaustVelocity
						mPropellant = Math.max(0, mPropellant - fuelFlowRate * tStep2[tStepState])
						if ((mPropellant == 0) && !warningAlreadyGiven) {
							console.log("Out of propellant!")
							warningAlreadyGiven = true
						}
						m0 = mVehicle + mPayload + mPropellant

						if (tStepState!=1) launchTrajectoryCurveControlPoints.push(vehiclePosition)
						altitudeVesusTimeData.push(new THREE.Vector3(t, altitude, 0))
						downrangeDistanceVersusTimeData.push(new THREE.Vector3(t, downrangeDistance, 0))
						speedVersusTimeData.push(new THREE.Vector3(t, vehicleAirSpeed, 0))
						forwardAccelerationVersusTimeData.push(new THREE.Vector3(t, 0, 0))
						lateralAccelerationVersusTimeData.push(new THREE.Vector3(t, 0, 0))
						aerodynamicDragVersusTimeData.push(new THREE.Vector3(t, aerodynamicDrag, 0)) // ToDo: Should make this a function of the level of vacuum and type of gas inside the suspended evacuated tube
						totalMassVerusTimeData.push(new THREE.Vector3(t, m0, 0))
						// Cause the value of t to make some extra stops when t ~= t3
						let nextTStepState = tStepState
						if ((tStepState==0) && (t<t3) && (t+tStep2[0]>=t3)) {
							if (t+tStep2[0]==t3) {
								nextTStepState = 4
							}
							else {
								nextTStepState = 1
								tStep2[1] = t3 - t    // Step needed to make a stop at t3
								tStep2[2] = t + tStep2[0] - t3 // Step needed to resume the previous cadence afetr t3
							}
						}
						else if ((tStepState>0) && (tStepState<3)) {
							nextTStepState = tStepState + 1
						}
						tStepState = nextTStepState
						lastR = RV.R
					}
					//console.log('done')
					this.durationOfLaunchTrajectory = t
					this.launcherEvacuatedTubeLength = distanceTravelledWithinEvacuatedTube
					distanceTravelled += distanceTravelledWithinEvacuatedTube
					const totalLengthOfLaunchSystem = distanceTravelled
					distanceTravelled += distanceTravelledOutsideLaunchSystem

					// Now create a curve consisting of equally spaced points to be the backbone of the mass driver object
					const numMassDriverCurveSegments = 128
					for (let i = 0; i <= numMassDriverCurveSegments; i++) {
						const d = i / numMassDriverCurveSegments * launcherMassDriverLength
						// Rotate the massDriverExitPosition around the axisOfRotation using the angle derived from the distance travelled
						vehiclePosition = massDriverExitPosition.clone().applyAxisAngle(this.axisOfRotation, (d - launcherMassDriverLength)  / l1)
						massDriverCurveControlPoints.push(vehiclePosition)
					}

					// Create a curve along the part of the trajectory where the vehicle coasts on a hyperbolic trajectory within the evacuated tube
					const numEvacuatedTubeCurveSegments = 128
					for (let i = 0; i <= numEvacuatedTubeCurveSegments; i++) {
						const t5 = i / numEvacuatedTubeCurveSegments * this.timeWithinEvacuatedTube
						const RV = this.RV_from_R0V0andt(R0.x, R0.y, V0.x, V0.y, t5)
						const downrangeAngle = downrangeDistanceTravelledOnRamp/radiusOfPlanet + Math.atan2(RV.R.y, RV.R.x)
						vehiclePosition = massDriverExitPosition.clone().applyAxisAngle(this.axisOfRotation, downrangeAngle).multiplyScalar(RV.R.length() / l1)
						evacuatedTubeCurveControlPoints.push(vehiclePosition)
					}
					//this.LaunchTrajectoryMarker3.position.copy(vehiclePosition)

					// Make a curve for the launch trajectory
					this.launchTrajectoryCurve = new THREE.CatmullRomSuperCurve3(launchTrajectoryCurveControlPoints)
					this.launchTrajectoryCurve.curveType = 'centripetal'
					this.launchTrajectoryCurve.closed = false
					this.launchTrajectoryCurve.tension = 0

					// Make a curve for the suspended evacuated tube
					this.evacuatedTubeCurve = new THREE.CatmullRomSuperCurve3(evacuatedTubeCurveControlPoints)
					this.evacuatedTubeCurve.curveType = 'centripetal'
					this.evacuatedTubeCurve.closed = false
					this.evacuatedTubeCurve.tension = 0

					// ToDo: Probably update should be calling this function, not the other way around.
					this.update(dParamWithUnits)

		// this.xyChart.drawAxes()
		// this.xyChart.labelAxes()
		// this.xyChart.addCurve("Altitude", "m", altitudeVesusTimeData, 0xff0000, "Red")  // Red Curve
		// this.xyChart.addCurve("Downrange Distance", "m", downrangeDistanceVersusTimeData, 0xff00ff, "Purple")  // Purple Curve
		// this.xyChart.addCurve("Speed", "m/s", speedVersusTimeData, 0x00ffff, "Cyan")  // Cyan Curve
		// this.xyChart.addCurve("Aerodynmic Drag", "N", aerodynamicDragVersusTimeData, 0x80ff80, "Bright Green") // Bright Green Curve
		// this.xyChart.addCurve("Vehicle Mass", "kg", totalMassVerusTimeData, 0x0000ff, "Blue") // Blue Curve
		// this.xyChart.addCurve("Forward Accelleration", "m/s2", forwardAccelerationVersusTimeData, 0xffff00, "Yellow") // Yellow Curve
		// this.xyChart.addCurve("Lateral Accelleration", "m/s2", lateralAccelerationVersusTimeData, 0xff8000, "Orange") // Orange Curve

		// console.print('========================================')
		// let peakAerodynamicDrag = 0
		// this.xyChart.curveInfo.forEach(curve =>{
		// 	console.print(curve.name, '(', curve.colorName, ')', curve.maxY)
		// 	if (curve.name == 'Aerodynmic Drag') {
		// 		peakAerodynamicDrag = curve.maxY
		// 	}
		// })
		// console.print("Vehicle Peak Aerodynamic Drag", Math.round(peakAerodynamicDrag/1000), 'kN')
		// console.print("RS-25 Engine Thrust 2279 kN")
		// console.print("Vehicle Initial Mass", Math.round(m0), 'kg')
		// console.print("MassDriver Time", Math.round(launcherMassDriverAccelerationTime*100/60)/100, 'min')
		// console.print("Ramp Time", Math.round(this.curveUpTime*10)/10, 'sec')
		// console.print("Evacuate Tube Time", Math.round(this.timeWithinEvacuatedTube*10)/10, 'sec')
		// console.print("MassDriver Length", Math.round(this.launcherMassDriverLength/1000), 'km')
		// console.print("Ramp Base Length", Math.round(rampBaseLength/1000), 'km')
		// console.print("Evacuate Tube Length", Math.round(distanceTravelledWithinEvacuatedTube/1000), 'km')
		// console.print("Total Length Of Launch System", Math.round(totalLengthOfLaunchSystem/1000), 'km')
		// console.print('========================================')

				}

				drawLaunchTrajectoryLine(dParamWithUnits, planetCoordSys) {
					let tStep = 1 // second
					let t = 0
					let prevVehiclePosition, currVehiclePosition
					
					prevVehiclePosition = this.launchTrajectoryCurve.getPoint(t / this.durationOfLaunchTrajectory)
					t += tStep

					const color = new THREE.Color()
					const launchTrajectoryPoints = []
					const launchTrajectoryColors = []

					for (; t < this.timeWithinMassDriver + dParamWithUnits['launcherCoastTime'].value; t+=tStep) {
						currVehiclePosition = this.launchTrajectoryCurve.getPoint(t / this.durationOfLaunchTrajectory)
						launchTrajectoryPoints.push(prevVehiclePosition)
						launchTrajectoryPoints.push(currVehiclePosition)
						prevVehiclePosition = currVehiclePosition.clone()
						// This code adds major thick hash marks to the line every 60 seconds, and thin hash marks every 10 seconds.
						if ((t%10==9) || (t%60==58)) {
							color.setHSL(0.0 , 0.2, 0.4 )
						}
						else {
							color.setHSL(0.35 , 0.2, 0.95 )
						}
						launchTrajectoryColors.push(color.r, color.g, color.b)
						launchTrajectoryColors.push(color.r, color.g, color.b)
					}

					const launchTrajectoryGeometry = new THREE.BufferGeometry().setFromPoints(launchTrajectoryPoints)
					launchTrajectoryGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( launchTrajectoryColors, 3 ) )
				
					var launchTrajectoryMaterial = new THREE.LineBasicMaterial({
						vertexColors: true,
						transparent: true,
						opacity: dParamWithUnits['launchTrajectoryVisibility'].value
					})

					if (this.launchTrajectoryMesh) {
						planetCoordSys.remove( this.launchTrajectoryMesh )
					}
					this.launchTrajectoryMesh = new THREE.LineSegments(launchTrajectoryGeometry, launchTrajectoryMaterial)
					this.launchTrajectoryMesh.visible = dParamWithUnits['showLaunchTrajectory'].value
					planetCoordSys.add( this.launchTrajectoryMesh )
				}

				animate(timeSinceStart) {
					// Move the virtual models of the launched vehicles along the launch trajectory
					let wedgeIndex
					const assignModelList = []
					const removeModelList = []
					const updateModelList = []
				
					this.unallocatedLaunchVehicleModels = []
					this.unallocatedLaunchSledModels = []

					this.refFrames.forEach((refFrame, index) => {
						// ToDo: Why check the flags for this?
						if (this.animateLaunchVehicles || this.animateLaunchSleds) {
						refFrame.timeSinceStart = timeSinceStart
						}
						const clearFlagsList = []
						//if (cameraAltitude<this.crv.currentMainRingAltitude+cameraRange) {
						
						// Hack - We'll just scan all of the wedges for now
						refFrame.startWedgeIndex = 0
						refFrame.finishWedgeIndex = this.numWedges - 1
					
						// Set bit0 of actionFlags if wedge is currently visible
						if (refFrame.startWedgeIndex!=-1) {
							for (wedgeIndex = refFrame.startWedgeIndex; ; wedgeIndex = (wedgeIndex + 1) % this.numWedges) {
								this.actionFlags[wedgeIndex] |= 1
								clearFlagsList.push(wedgeIndex)
								if (wedgeIndex == refFrame.finishWedgeIndex) break
							}
						}
						// Set bit1 of actionFlags if wedge was previously visible
						if (refFrame.prevStartWedgeIndex!=-1) {
							for (wedgeIndex = refFrame.prevStartWedgeIndex; ; wedgeIndex = (wedgeIndex + 1) % this.numWedges) {
								this.actionFlags[wedgeIndex] |= 2
								clearFlagsList.push(wedgeIndex)
								if (wedgeIndex == refFrame.prevFinishWedgeIndex) break
							}
						}
				
						if (refFrame.startWedgeIndex!=-1) {
							for (wedgeIndex = refFrame.startWedgeIndex; ; wedgeIndex = (wedgeIndex + 1) % this.numWedges) {
								if (this.actionFlags[wedgeIndex]==1) {
									// Wedge wasn't visible before and it became visible, assign it the assignModel list
									assignModelList.push({'refFrame': refFrame, 'wedgeIndex': wedgeIndex})
								}
								if (this.actionFlags[wedgeIndex] & 1 == 1) {
									// Wedge is currently visible, assign it the updateModel list
									updateModelList.push({'refFrame': refFrame, 'wedgeIndex': wedgeIndex})
								}
								if (wedgeIndex == refFrame.finishWedgeIndex) break
							}
						}
						if (refFrame.prevStartWedgeIndex!=-1) {
							for (wedgeIndex = refFrame.prevStartWedgeIndex; ; wedgeIndex = (wedgeIndex + 1) % this.numWedges) {
								if (this.actionFlags[wedgeIndex]==2) {
									// Wedge was visible before and it became invisible, add it to the removeModel list
									removeModelList.push({'refFrame': refFrame, 'wedgeIndex': wedgeIndex})
								}
								if (wedgeIndex == refFrame.prevFinishWedgeIndex) break
							}
						}
						
						// Debug - ToDo clean this up when it's no longer needed
						// let different = false
						// for (let j=0; j<this.actionFlags.length; j++) {
						//   if (this.actionFlags[j]!=refFrame.prevActionFlags[j]) {
						//     different = true
						//     break
						//   }
						// }
						// if (different) {
						//   let prstr = ''
						//   for (let j = 0; j<this.actionFlags.length; j++) {
						//     prstr += String(this.actionFlags[j])
						//   }
						//   console.log(prstr)
						// }
						// for (let j=0; j<this.actionFlags.length; j++) {
						//   refFrame.prevActionFlags[j] = this.actionFlags[j]
						// }
				
						refFrame.prevStartWedgeIndex = refFrame.startWedgeIndex
						refFrame.prevFinishWedgeIndex = refFrame.finishWedgeIndex
				
						clearFlagsList.forEach(wedgeIndex => {
							this.actionFlags[wedgeIndex] = 0  // Clear the action flags to ready them for future reuse
						})
					})


					// Reassign models to/from virtual models based on which objects are in range of the camera
					// Place and orient all of the active models
					if (removeModelList.length > 0) {
						// console.log(
						//   this.unallocatedMassDriverModels.length,
						//   this.unallocatedLaunchVehicleModels.length,
						// )
						//console.log('Removing ' + removeModelList.length)
					}
					if (assignModelList.length > 0) {
						// console.log(
						//   this.unallocatedMassDriverModels.length,
						//   this.unallocatedLaunchVehicleModels.length,
						// )
						//console.log('Adding ' + assignModelList.length)
					}
				
					// Free models that are in wedges that are no longer near the camera
					removeModelList.forEach(entry => {
						Object.entries(entry['refFrame'].wedges[entry['wedgeIndex']]).forEach(([objectKey, objectValue]) => {
							objectValue.forEach(object => {
								if (object.model) {
									object.model.visible = false
									if (object.hasElement('unallocatedModels')) {
										object.unallocatedModels.push(object.model)
										object.model = null
									}
								}
							})
						})
					})
				
					// Assign models to virtual objects that have just entered the region near the camera
					assignModelList.forEach(entry => {
						const ranOutOfModelsInfo = {}
						Object.entries(entry['refFrame'].wedges[entry['wedgeIndex']]).forEach(([objectKey, objectValue]) => {
							if (objectValue.length>0) {
								objectValue.forEach(object => {
									if (!object.model) {
										if (object.unallocatedModels.length==1) {
											// This is the last model. Duplicate it so that we don't run out.
											const tempModel = object.unallocatedModels[0].clone()
											object.unallocatedModels.push(tempModel)
											this.scene.add(tempModel)
											//console.log('Duplicating model for ' + objectKey)
										}
										if (object.unallocatedModels.length>0) {
											object.model = object.unallocatedModels.pop()
											object.model.visible = object.isVisible
										}
										else {
											if (objectKey in ranOutOfModelsInfo) {
												ranOutOfModelsInfo[objectKey]++
											}
											else {
												ranOutOfModelsInfo[objectKey] = 1
											}
										}
									}
									else {
										object.model.visible = object.isVisible
									}
								})
								const classIsDynamic = objectValue[0].constructor.isDynamic
								const classHasChanged = objectValue[0].constructor.hasChanged
								if (!classIsDynamic && !classHasChanged) {
									// Static object so we will place the model (just once) at the same time we assign it to a virtual object
									objectValue.forEach(object => {
										if (object.model) {
											object.placeAndOrientModel(object.model, entry['refFrame'])
										}
									})
								}
							}
						})
						let allGood = true
						Object.entries(ranOutOfModelsInfo).forEach(([k, v]) => {
							if (v>0) {
								console.log('Ran out of ' + k + ' models (needed ' + v + ' more)')
								allGood = false
							}
						})
						if (!allGood) {
							console.log('Problem Assigning Models')
						}
						else {
							// Success!! We can remove this entry from the list now
							//assignModelList.splice(index, 1)
						}
					})
					// Now adjust the models position and rotation in all of the active wedges
				
					updateModelList.forEach(entry => {
						Object.entries(entry['refFrame'].wedges[entry['wedgeIndex']]).forEach(([objectKey, objectValue]) => {
							if (objectValue.length>0) {
								const classIsDynamic = objectValue[0].constructor.isDynamic
								const classHasChanged = objectValue[0].constructor.hasChanged
								if (true || classIsDynamic || classHasChanged) {
									// Call the placement method for each active instance (unless the model class is static and unchanged)
									objectValue.forEach(object => {
										if (object.model) {
										object.placeAndOrientModel(object.model, entry['refFrame'])
										}
									})
								}
							}
						})
					})
				
					if (removeModelList.length > 0) {
						// console.log(
						//   this.unallocatedMassDriverModels.length,
						//   this.unallocatedLaunchVehicleModels.length,
						// )
					}
					if (assignModelList.length > 0) {
						// console.log(
						//   this.unallocatedMassDriverModels.length,
						//   this.unallocatedLaunchVehicleModels.length,
						// )
					}
				
					// Clear all of the "hasChanged" flags
					virtualMassDriverTube.hasChanged = false
					virtualMassDriverRail.hasChanged = false
					virtualMassDriverBracket.hasChanged = false
					virtualMassDriverScrew.hasChanged = false
					virtualLaunchVehicle.hasChanged = false
					virtualLaunchSled.hasChanged = false
				
					// Debug stuff...
					// console.log(ringTerminusModels)
					// if (transitVehicleShortageCount>0) {
					//   console.log('transitVehicleShortageCount was ' + transitVehicleShortageCount)
					// }
					// // console.log("vehicles unallocated: " + this.unallocatedTransitVehicleModels.length)
					// if (removeModelList.length) {
					//   console.log("removing " + removeModelList.length + " wedge")
					// }
					// if (assignModelList.length) {
					//   console.log("assigning " + assignModelList.length + " wedge")
					// }
				
				}


				Update() {
					// TBD these parameters should come from "the universe"
					console.log('Executing unused code!')
					this.R_LEO = this.R_Earth + this.Alt_LEO;

					this.PotentialEnergy_Joules = -this.const_G * this.const_M * this.MPayload / this.R_Earth;
					this.PotentialEnergy_kWh = this.PotentialEnergy_Joules / 3600000;
					this.CostOfPotentialEnergyToEscape = -this.PotentialEnergy_kWh * this.WholesaleElectricityCost;
					this.CostPerkgToEscape = this.CostOfPotentialEnergyToEscape / this.MPayload;
					this.LEOOrbitVelocity = Math.sqrt(this.const_G*this.const_M / (this.R_Earth + this.Alt_LEO));
					this.Alt_Apogee = this.Alt_LEO;
					this.EllipseMajorAxisLength = this.Alt_Perigee + this.R_Earth * 2 + this.Alt_Apogee;
					this.EllipseSemiMajorAxisLength = this.EllipseMajorAxisLength / 2;
					this.Eccentricity = 1.0 - (this.R_Earth + this.Alt_Perigee) / this.EllipseSemiMajorAxisLength;
					this.EllipseSemiMinorAxisLength = this.EllipseSemiMajorAxisLength * Math.sqrt(1 - this.Eccentricity**2);

					this.EllipticalOrbitPerigeeVelocity = Math.sqrt(this.const_G*this.const_M*(2 / (this.R_Earth + this.Alt_Perigee) - 2 / this.EllipseMajorAxisLength));
					this.EllipticalOrbitApogeeVelocity = Math.sqrt(this.const_G*this.const_M*(2 / (this.R_Earth + this.Alt_Apogee) - 2 / this.EllipseMajorAxisLength));
					this.EllipticalOrbitVelocityAtLauncherExit = Math.sqrt(this.const_G * this.const_M * (2 / (this.R_Earth + this.Alt_EvacuatedTube) - (1 / this.EllipseSemiMajorAxisLength)));
					this.EllipticalOrbitPeriod = 2 * Math.PI * Math.sqrt(Math.pow(this.EllipseSemiMajorAxisLength, 3) / (this.const_G * this.const_M));
					this.EarthsRimSpeed = 2 * Math.PI*(this.R_Earth + this.Alt_Perigee) / 24 / 3600;  // ToDo: This needs to be a function of where edge of ring is
					this.DeltaVeeToCircularizeOrbit = this.LEOOrbitVelocity - this.EllipticalOrbitApogeeVelocity;
					this.DeltaVeeToDeCircularizeOrbit = this.DeltaVeeToCircularizeOrbit; // Need this much DeltaV to return to Earth
					this.TotalDeltaV = this.DeltaVeeToCircularizeOrbit + this.DeltaVeeToDeCircularizeOrbit;
					this.M0OverMf = Math.exp(this.TotalDeltaV / (this.RocketsSpecificImpulse*this.const_g));
					this.FueledVehicleMassAtApogee = (this.MPayload + this.RocketEnginesMass)*this.M0OverMf;
					this.FueledVehiclesKineticEnergyAtPerigee_Joules = 0.5*this.FueledVehicleMassAtApogee*(this.EllipticalOrbitPerigeeVelocity - this.EarthsRimSpeed)**2;
					this.FueledVehiclesKineticEnergyAtPerigee_kWh = this.FueledVehiclesKineticEnergyAtPerigee_Joules / 3600000;
					this.CostToLaunchFueledVehicle = this.FueledVehiclesKineticEnergyAtPerigee_kWh * this.LauncherEfficiency * this.WholesaleElectricityCost;
					this.CostPerkgOfPayload = this.CostToLaunchFueledVehicle / this.MPayload;

					// Next, we will work out the length of the launcher's track and the launch time...
					this.LauncherTrackLength = 0.5*(this.EllipticalOrbitPerigeeVelocity - this.EarthsRimSpeed)**2 / (this.MaxGees*this.const_g);
					this.AccelerationTime = Math.sqrt(2 * this.LauncherTrackLength / (this.MaxGees*this.const_g));
					// A rough approximation here - assuming that the S curve is close to flat so we can just subtract or add one Gee to account for Earth's Gravity 
					this.AllowableUpwardTurningRadius = this.EllipticalOrbitPerigeeVelocity**2 / ((this.MaxGees - 1)*this.const_g);
					this.AllowableDownwardTurningRadius = this.EllipticalOrbitPerigeeVelocity**2 / ((this.MaxGees + 1)*this.const_g);
					if (this.Alt_Perigee > this.LauncherAltitude) {
						// In this case we know that the optimal release point is at the orbit's perigee.
						const TriangleSideA = this.R_Earth + this.Alt_Perigee - this.AllowableDownwardTurningRadius;
						const TriangleSideB = this.R_Earth + this.LauncherAltitude + this.AllowableUpwardTurningRadius;
						const TriangleSideC = this.AllowableUpwardTurningRadius + this.AllowableDownwardTurningRadius;
						const AngleA = Math.acos((TriangleSideA**2 - TriangleSideB**2 - TriangleSideC**2) / (-2 * TriangleSideB*TriangleSideC));
						const AngleB = Math.acos((TriangleSideB**2 - TriangleSideA**2 - TriangleSideC**2) / (-2 * TriangleSideA*TriangleSideC));
						const AngleD = Math.PI - AngleB;
						this.CurveUpDistance = AngleA * this.AllowableUpwardTurningRadius;
						this.CurveDownDistance = AngleD * this.AllowableDownwardTurningRadius;
					}
					else {
						// In this case the optimal release point is not the eliptical orbit's perigee, but rather the point where the eliptical orbit 
						// intercects with Alt_EvacuatedTubeHeight, or the highest altitude at which it is feasible to use the launch system to alter
						// the tragectory of the vehicle. We need to figure out the location of this point and the velocity vector at that point.

						this.CurveUpDistance = 0;
						this.CurveDownDistance = 0;
					}
					this.TotalSCurveDistance = this.CurveUpDistance + this.CurveDownDistance;
					this.CurveUpTime = this.CurveUpDistance / this.EllipticalOrbitPerigeeVelocity;
					this.CurveDownTime = this.CurveDownDistance / this.EllipticalOrbitPerigeeVelocity;
					this.TotalTimeInLaunchSystem = this.AccelerationTime + this.CurveUpTime + this.CurveDownTime;
					this.VehicleCrossSectionalAreaForDrag = Math.PI * this.VehicleRadius ** 2
				}

				// The following functions were ported from 	// Equation 3.66c, http://www.nssc.ac.cn/wxzygx/weixin/201607/P020160718380095698873.pdf

				stumpC(z) {
					let c

					if (z > 0) {
						c = (1 - Math.cos(Math.sqrt(z))) / z
					}
					else if (z < 0) {
						c = (Math.cosh(Math.sqrt(-z)) - 1) / (-z)
					}
					else {
						c = 1 / 2
					}
					return c
				}

				stumpS(z) {

					let s

					if (z > 0) {
						const sqrtz = Math.sqrt(z)
						s = (sqrtz - Math.sin(sqrtz)) / Math.pow(sqrtz, 3)
					}
					else if (z < 0) {
						const sqrtmz = Math.sqrt(-z)
						s = (Math.sinh(sqrtmz) - sqrtmz) / Math.pow(sqrtmz, 3)
					}
					else {
						s = 1 / 6
					}
					return s
				}

				f_and_g(x, t, ro, a)
				{
					const fg = new THREE.Vector2()

					const z = a * x**2
					//Equation 3.66a:
					fg.x = 1 - x**2 / ro * this.stumpC(z)
					//Equation 3.66b:
					fg.y = t - 1 / Math.sqrt(this.mu) * x*x*x * this.stumpS(z)
					return fg
				}

				fDot_and_gDot(x, r, ro, a)
				{
					const fdotgdot = new THREE.Vector2()

					const z = a * x**2
					// Equation 3.66c:
					fdotgdot.x = Math.sqrt(this.mu) / r / ro * (z*this.stumpS(z) - 1)*x
					// Equation 3.66d:
					fdotgdot.y = 1 - x**2 / r * this.stumpC(z)
					return fdotgdot
				}

				kepler_U(dt, ro, vro, a) {
					let C, S, F
					let dFdx

					// Set an error tolerance and a limit on the number of iterations
					const error = 1e-8
					const nMax = 1000
					// Starting value for x
					let x = Math.sqrt(this.mu)*Math.abs(a)*dt
					// Iterate on Equation 3.62 until convergence occurs within the error tolerance
					let n = 0
					let ratio = 1

					while ((Math.abs(ratio) > error) && (n <= nMax)) {
						n = n + 1
						C = this.stumpC(a * x**2)
						S = this.stumpS(a * x**2)
						F = ro * vro / Math.sqrt(this.mu) * x**2 * C + (1 - a * ro) * x*x*x * S + ro * x - Math.sqrt(this.mu)*dt
						dFdx = ro * vro / Math.sqrt(this.mu) * x * (1 - a * x**2 * S) + (1 - a * ro) * x**2 * C + ro
						ratio = F / dFdx
						x = x - ratio
					}
					return x
				}

				RV_from_R0V0andt(R0_x, R0_y, V0_x, V0_y, t) {

					const R0 = new THREE.Vector2(R0_x, R0_y)
					const V0 = new THREE.Vector2(V0_x, V0_y)
					const RV = {
						R: new THREE.Vector2(0, 0),
						V: new THREE.Vector2(0, 0)
					}
					// mu - gravitational parameter(kmˆ3 / sˆ2)
					// R0 - initial position vector(km)
					// V0 - initial velocity vector(km / s)
					// t - elapsed time(s)
					// R - final position vector(km)
					// V - final velocity vector(km / s)
					// User M - functions required : kepler_U, f_and_g, fDot_and_gDot

					//Magnitudes of R0 and V0
					const r0 = R0.length()
					const v0 = V0.length()
					//Initial radial velocity
					const vr0 = R0.dot(V0) / r0

					// Reciprocal of the semimajor axis(from the energy equation)
					const alpha = 2 / r0 - v0**2 / this.mu
					// Compute the universal anomaly
					const x = this.kepler_U(t, r0, vr0, alpha)
					// Compute the f and g functions
					const fg = this.f_and_g(x, t, r0, alpha)

					// Compute the final position vector
					RV.R.x = fg.x * R0.x + fg.y * V0.x
					RV.R.y = fg.x * R0.y + fg.y * V0.y

					// Compute the magnitude of R
					const r = RV.R.length()
					
					// Compute the derivatives of f and g
					const fdotgdot = this.fDot_and_gDot(x, r, r0, alpha)

					// Compute the final velocity
					RV.V.x = fdotgdot.x * R0.x + fdotgdot.y * V0.x
					RV.V.y = fdotgdot.x * R0.y + fdotgdot.y * V0.y

					return RV
				}

				orbitalElementsFromStateVector(R, V) {
					// This function computes the classical orbital elements (coe)
					// from the state vector (R,V) using Algorithm 4.1.

					// mu - gravitational parameter (kmˆ3/sˆ2)
					// R - position vector in the geocentric equatorial frame
					// (km)
					// V - velocity vector in the geocentric equatorial frame
					// (km)
					// r, v - the magnitudes of R and V
					// vr - radial velocity component (km/s)
					// H - the angular momentum vector (kmˆ2/s)
					// h - the magnitude of H (kmˆ2/s)
					// incl - inclination of the orbit (rad)
					// N - the node line vector (kmˆ2/s)
					// n - the magnitude of N
					// cp - cross product of N and R
					// RA - right ascension of the ascending node (rad)
					// E - eccentricity vector
					// e - eccentricity (magnitude of E)
					// eps - a small number below which the eccentricity is
					// considered to be zero
					// w - argument of perigee (rad)
					// TA - true anomaly (rad)
					// a - semimajor axis (km)
					// pi - 3.1415926...
					// coe - vector of orbital elements [h e RA incl w TA a]

					// User M-functions required: None
					const eps = 1.e-10
					const r = R.length()
					const v = V.length()
					const vr = R.clone().dot(V) / r
					const H = R.clone().cross(V)
					const h = H.length()

					// Equation 4.7:
					const incl = Math.acos(H.z/h);

					// Equation 4.8:
					const N = new THREE.Vector3(0, 0, 1).cross(H)
					const n = N.length()

					// Equation 4.9:
					let RA
					if (n != 0) {
						RA = Math.acos(N.x/n)
						if (N.z < 0) {
							RA = 2*Math.PI - RA
						}
					}
					else {
						RA = 0
					}

					// Equation 4.10:
					const E = R.clone().multiplyScalar((v**2 - this.mu/r)).sub(V.clone().multiplyScalar(r*vr)).multiplyScalar(1/this.mu)
					const e = E.length()

					// Equation 4.12 (incorporating the case e = 0):
					let w
					if (n != 0) {
						if (e > eps) {
							w = Math.acos(N.clone().dot(E)/n/e)
							if (E.z < 0) {
								w = 2*Math.PI - w
							}
						}
						else {
							w = 0
						}
					}
					else {
						w = 0
					}

					// Equation 4.13a (incorporating the case e = 0):
					let TA
					if (e > eps) {
						TA = Math.acos(E.clone().dot(R)/e/r)
						if (vr < 0) {
							TA = 2*Math.PI - TA
						}
					}
					else {
						const cp = N.clone().cross(R)
						if (cp.z >= 0) {
							TA = Math.acos(N.clone().dot(R)/n/r)
						}
						else {
							TA = 2*Math.PI - Math.acos(N.clone().dot(R)/n/r)
						}
					}

					// Equation 2.61 (a < 0 for a hyperbola):
					const a = h**2/this.mu/(1 - e**2)

					return {
						'angularMomentumVector': h,
						'eccentricity': e,
						'rightAscensionOfTheAscendingNode': RA,
						'inclination': incl,
						'argumentOfPerigee': w,
						'trueAnomaly': TA,
						'semimajorAxis': a
					}
				}

				GetAltitudeDistanceAndVelocity(CurrentTime)
				{
					let ADAndV = {
						Altitude: 0,
						Distance: 0,
						Velocity: 0
					}

					if (CurrentTime <= this.AccelerationTime) {
						ADAndV.Altitude = this.LauncherAltitude
						ADAndV.Distance = 0.5 * this.MaxGees * this.const_g * CurrentTime**2
						ADAndV.Velocity = this.MaxGees * this.const_g * CurrentTime
					}
					else if (CurrentTime <= this.AccelerationTime + this.CurveUpTime) {
						ADAndV.Altitude = Math.sqrt((this.R_Earth + this.LauncherAltitude + this.AllowableUpwardTurningRadius)**2 + this.AllowableUpwardTurningRadius**2 - 2 * (this.R_Earth + this.LauncherAltitude + this.AllowableUpwardTurningRadius)*this.AllowableUpwardTurningRadius*Math.cos(Math.max(0, CurrentTime - this.AccelerationTime)*this.EllipticalOrbitPerigeeVelocity / this.AllowableUpwardTurningRadius)) - this.R_Earth;
						// ToDo: This is too rough and approximation
						ADAndV.Distance = this.LauncherTrackLength + (CurrentTime - this.AccelerationTime) * this.EllipticalOrbitPerigeeVelocity
						ADAndV.Velocity = this.EllipticalOrbitPerigeeVelocity
					}
					else if (CurrentTime <= this.TotalTimeInLaunchSystem) {
						ADAndV.Altitude = Math.sqrt((this.R_Earth + this.Alt_Perigee - this.AllowableDownwardTurningRadius)**2 + this.AllowableDownwardTurningRadius**2 - 2 * (this.R_Earth + this.Alt_Perigee - this.AllowableDownwardTurningRadius)*this.AllowableDownwardTurningRadius*Math.cos(Math.PI + Math.min(0, CurrentTime - this.TotalTimeInLaunchSystem)*this.EllipticalOrbitPerigeeVelocity / this.AllowableDownwardTurningRadius)) - this.R_Earth
						// ToDo: This is too rough and approximation
						ADAndV.Distance = this.LauncherTrackLength + (CurrentTime - this.AccelerationTime) * this.EllipticalOrbitPerigeeVelocity
						ADAndV.Velocity = this.EllipticalOrbitPerigeeVelocity
					}
					else {
						const Time = CurrentTime - this.TotalTimeInLaunchSystem
						const R0 = new THREE.Vector2(0, (this.R_Earth + this.Alt_Perigee) / 1000)
						const V0 = new THREE.Vector2(this.EllipticalOrbitPerigeeVelocity / 1000, 0)
						// TBD - need to figure out the altitude while on the eliptical orbit's path

						// Note: The distance units in the RV_from_R0V0andt function and its sub functions are km, not meters.
						const RV = this.RV_from_R0V0andt(R0.x, R0.y, V0.x, V0.y, Time)

						ADAndV.Altitude = RV.R.length() * 1000 - this.R_Earth
						ADAndV.Distance = Math.atan2(RV.R.x, RV.R.y) * RV.R.length() * 1000
						ADAndV.Velocity = RV.V.length() * 1000
					}
					return ADAndV
				}

				GetAirDensity(Altitude)
				{
					let T, P
					if (Altitude < 11000.0) {
						T = 15.04 - 0.00649*Altitude
						P = 101.29 * Math.pow((T + 273.1) / 288.08, 5.256)
					}
					else if (Altitude < 25000.0) {
						T = -56.46
						P = 22.65*Math.exp(1.73 - 0.000157*Altitude)
					}
					else {
						T = -131.21 + 0.00299*Altitude
						P = 2.488*Math.pow((T + 273.1) / 216.6, -11.388)
					}
					const Density = P / (0.2869*(T + 273.1))

					return Density

					// Reference https://www.grc.nasa.gov/WWW/k-12/airplane/atmosmet.html
				}

				GetAerodynamicDrag(CurrentAirDensity, Speed)
				{
					const DragForce = CoefficientOfDrag * VehicleCrossSectionalAreaForDrag * (Speed - EarthsRimSpeed)**2 / 2 * CurrentAirDensity
					return DragForce;
				}

			// ChatGPT version
			GetAerodynamicDrag_ChatGPT(altitude, speed, noseConeAngle, radius, length) {
				// Calculate the atmospheric density at the given altitude using the barometric formula
				const density = this.GetAirDensity(altitude)
				
				// Calculate the drag coefficient based on the nose cone angle and length
				// const dragCoefficient = 0.5 * Math.pow(Math.cos(noseConeAngle), 2) + (length / (Math.PI * radius * radius)) // Suspect this formula is BS
				const dragCoefficient = 0.035  // From page 23 of https://upcommons.upc.edu/bitstream/handle/2117/328318/REPORT_556.pdf?sequence=1&isAllowed=y
				
				// Calculate the cross-sectional area of the object
				const crossSectionalArea = Math.PI * radius * radius
				
				// Calculate the drag force using the drag equation
				const dragForce = 0.5 * dragCoefficient * density * speed * speed * crossSectionalArea
				
				return dragForce;
				}				
			}

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x0f0f0f );

				const fov = 45 // dParamWithUnits['cameraFieldOfView'].value
				const aspectRatio = window.innerWidth / window.innerHeight
				camera = new THREE.PerspectiveCamera(fov, aspectRatio, nearClippingPlane, farClippingPlane)
				//camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				//camera.position.set( 0, 250, 1000 );

				scene.add( camera );
				
				const sunLight = new THREE.DirectionalLight(0x0f0f0f0, 2)
				sunLight.name = 'sunlight'
				sunLight.position.set(0, -6 * radiusOfPlanet/8, -20 * radiusOfPlanet/8)
				scene.add(sunLight)

				const ambientLight = new THREE.AmbientLight(0x4f4f4f, 0.5)
				ambientLight.name = 'ambientLight'
				scene.add(ambientLight)

				let planetWidthSegments = 768
				let planetHeightSegments = 192

				planetCoordSys = new THREE.Group()
				scene.add(planetCoordSys)

				tetheredRingRefCoordSys = new THREE.Group();
				tetheredRingRefCoordSys.name = 'tetheredRingRefCoordSys'
				planetCoordSys.add(tetheredRingRefCoordSys)
				gimbalMath()

				planetMeshes = new THREE.Group()
				planetMeshes.name = 'planetMeshes'

				const generateMipmaps = true // Set to true for higher quality, false for faster load time
				let textureFilename
				let displacementMap
				const w = 24
				const h = 12
				const displacementScale = 6600
				const displacementBias = -930.7
				const earthTextureOpacity = 1

				// Low-res whole planet
				const texture = new THREE.TextureLoader().load( './textures/terrain/bluemarble_4096.jpg')
				texture.generateMipmaps = generateMipmaps
				planetWidthSegments = 768
				planetHeightSegments = 192

				const wholePlanetMesh = new THREE.Mesh(
					new THREE.SphereGeometry(radiusOfPlanet * 0.9995, planetWidthSegments, planetHeightSegments),
					new THREE.MeshStandardMaterial({map: texture})
				)
				wholePlanetMesh.name = 'lowResPlanet'
				wholePlanetMesh.rotation.y = -Math.PI/2  // This is needed to have the planet's texture align with the planet's Longintitude system
				wholePlanetMesh.receiveShadow = true
				planetMeshes.add(wholePlanetMesh)

				for (let j=0; j<h; j++) {
					for (let i = 0; i<w; i++) {
						const textureFileAvailible = ((i==1) && (j==4))
						if (textureFileAvailible) {
							const pointOnEarthsSurface = new THREE.Vector3().setFromSphericalCoords(
								radiusOfPlanet, 
								Math.PI * (1+2*j)/(2*h),
								Math.PI * (1 + (1+2*i)/w)
							)
							const localPoint = tetheredRingRefCoordSys.worldToLocal(pointOnEarthsSurface.clone())
 
							planetWidthSegments = 768*64
						    planetHeightSegments = 192*64
							textureFilename = `./textures/terrain/earth_HR_${w}x${h}_${i}x${j}.jpg`
							const texture = new THREE.TextureLoader().load(textureFilename)
						    texture.generateMipmaps = generateMipmaps
							const displacementFilename = `./textures/terrain/earthDisplacement_HR_${w}x${h}_${i}x${j}.png`
					        displacementMap = new THREE.TextureLoader().load(displacementFilename)
							//displacementMap.generateMipmaps = generateMipmaps

							const planetGeometry = new THREE.SphereGeometry(radiusOfPlanet, planetWidthSegments/w, planetHeightSegments/h, i*Math.PI*2/w, Math.PI*2/w, j*Math.PI/h, Math.PI/h)
							const planetMesh = new THREE.Mesh(
								planetGeometry,
								new THREE.MeshStandardMaterial({
									map: texture,
									displacementMap: displacementMap,
									displacementScale: displacementScale,
									displacementBias: displacementBias,
									transparent: true,
									opacity: earthTextureOpacity,
									wireframe: false    // Make control
								}),
							)
							planetMesh.name = 'highResPlanet'
							planetMesh.rotation.y = -Math.PI/2  // This is needed to have the planet's texture align with the planet's Longintitude system
							//planetMesh.receiveShadow = true
							planetMeshes.add(planetMesh)
					    }
					}
				}
				planetCoordSys.add(planetMeshes)

				const launchVehicleMesh = new launchVehicleModel(1.2, 10, 20, 15, 5, 0.2, 1.2)
				launchVehicleMesh.position.set(-2316265.9940429763, 2220230.3502845275, -5548271.348861104)
				launchVehicleMesh.scale.set(1000, 1000, 1000)
				scene.add(launchVehicleMesh)

				const dParamWithUnits = {
					launcherMassDriverForwardAcceleration: {value: 50},
					launcherMassDriverUpwardAcceleration: {value: 80},
					launcherMassDriverAltitude: {value: 0},
					launcherEvacuatedTubeExitAltitude: {value: 15000},
					launcherRampExitAltitude: {value: 4169.4},
					launcherRampEndLatitudeDegreesN: {value: 19.479488},
					launcherRampEndLonitudeDegreesE: {value: -155.602829},
					launcherMassDriverInitialVelocity: {value: 210},
					launcherMassDriverExitVelocity: {value: 8000},
					launchVehicleRocketExhaustVelocity: {value: 4436},
					launchVehicleEmptyMass: {value: 1000},
					launchVehiclePayloadMass: {value: 100},
					launchVehiclePropellantMass: {value: 9500},
					launchVehicleRadius: {value: 1.2},
					launchVehicleBodyLength: {value: 10},
					launchVehicleNoseConeLength: {value: 20},
					launcherCoastTime: {value: 250},
					launcherMarkerRadius: {value: 500},
					launchVehicleSpacingInSeconds: {value: 5},
					launcherSlowDownPassageOfTime: {value: 0.01},
					showLaunchTrajectory: {value: true},
					launchTrajectoryVisibility: {value: 1.0},
					showLaunchVehicles: {value: true},
					showLaunchVehiclePointLight: {value: true},
					showXYChart: {value: false},
					animateLaunchVehicles: {value: true},
					perfOptimizedThreeJS: {value: false},
				};

				// ToDo: Fully implement sceneOrtho
				let sceneOrtho = new THREE.Scene()
				const xyChart = new XYChart(sceneOrtho)
				const launchSystem = new launcher(dParamWithUnits, planetCoordSys, radiusOfPlanet, xyChart, clock);
				launchSystem.updateTrajectoryCurves(dParamWithUnits, planetCoordSys, radiusOfPlanet);
				launchSystem.drawLaunchTrajectoryLine(dParamWithUnits, planetCoordSys);

				
				document.addEventListener( 'keydown', onKeyDown )

				document.addEventListener('mousemove', (event) => {
					mouse.x = 2 * (event.clientX / window.innerWidth) - 1
					mouse.y = 1 - 2 * (event.clientY / window.innerHeight)
				})

				document.addEventListener('dblclick', onDoubleClick);


				// const planeGeometry = new THREE.PlaneGeometry( 2000, 2000 );
				// planeGeometry.rotateX( - Math.PI / 2 );
				// const planeMaterial = new THREE.ShadowMaterial( { color: 0x000000, opacity: 0.2 } );

				// const plane = new THREE.Mesh( planeGeometry, planeMaterial );
				// plane.position.y = - 200;
				// plane.receiveShadow = true;
				// scene.add( plane );

				const helper = new THREE.GridHelper( 2000, 100 );
				helper.position.y = - 199;
				helper.material.opacity = 0.25;
				helper.material.transparent = true;
				scene.add( helper );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );

				const gui = new GUI();

				gui.add( params, 'uniform' ).onChange( render );
				gui.add( params, 'tension', 0, 1 ).step( 0.01 ).onChange( function ( value ) {
					splines.uniform.tension = value;
					updateSplineOutline();
					render();
				} );
				gui.add( params, 'logZoomRate', -4, 0).step( 0.01 ).onChange( function ( value ) { logZoomRate = value });
				gui.add( params, 'elevationFactor', 0, 20).step( 0.01 ).onChange( function ( value ) {
					planetMeshes.traverse(child => {
						if (child.name === 'highResPlanet') {
							child.material.displacementScale = 6600 * value;
							child.material.displacementBias = -930.7 * value;
							child.material.needsUpdate = true;
							renderer.render(scene, camera, null, true);
						}
					});
				});
				gui.add( params, 'logRocketScale', 0, 8).step( 0.01 ).onChange( function ( value ) {
					const expValue = Math.exp(value)
					launchVehicleMesh.scale.set(expValue, expValue, expValue);
				});
				gui.add( params, 'massDriverAcceleration', 5, 1000).step( 1 ).onChange( function ( value ) {
					dParamWithUnits['launcherMassDriverForwardAcceleration'].value = value
					launchSystem.updateTrajectoryCurves(dParamWithUnits, planetCoordSys, radiusOfPlanet);
					launchSystem.drawLaunchTrajectoryLine(dParamWithUnits, planetCoordSys);
				});
				gui.add( params, 'rampUpwardAcceleration', 5, 1000).step( 1 ).onChange( function ( value ) {
					dParamWithUnits['launcherMassDriverUpwardAcceleration'].value = value
					launchSystem.updateTrajectoryCurves(dParamWithUnits, planetCoordSys, radiusOfPlanet);
					launchSystem.drawLaunchTrajectoryLine(dParamWithUnits, planetCoordSys);
				});
				gui.add( params, 'massDriverAltitude', 0, 100000).step( 1 ).onChange( function ( value ) {
					dParamWithUnits['launcherMassDriverAltitude'].value = value
					launchSystem.updateTrajectoryCurves(dParamWithUnits, planetCoordSys, radiusOfPlanet);
					launchSystem.drawLaunchTrajectoryLine(dParamWithUnits, planetCoordSys);
				});
				gui.add( params, 'launcherRampExitAltitude', 3000, 10000).step( 1 ).onChange( function ( value ) {
					dParamWithUnits['launcherRampExitAltitude'].value = value
					launchSystem.updateTrajectoryCurves(dParamWithUnits, planetCoordSys, radiusOfPlanet);
					launchSystem.drawLaunchTrajectoryLine(dParamWithUnits, planetCoordSys);
				});
				gui.add( params, 'sunlightIntensity', 0, 5).onChange( function (value) {sunLight.intensity = value});
				gui.add( params, 'ambientLightIntensity', 0, 5).onChange( function (value) {ambientLight.intensity = value});
				gui.add( params, 'centripetal' ).onChange( render );
				gui.add( params, 'chordal' ).onChange( render );
				gui.add( params, 'addPoint' );
				gui.add( params, 'removePoint' );
				gui.add( params, 'exportSpline' );
				gui.open();

				// Controls
				orbitControls = new OrbitControls( camera, renderer.domElement );
				orbitControls.damping = 0.2;
				orbitControls.autoRotate = true
				orbitControls.autoRotateSpeed = 0.1
				orbitControls.addEventListener( 'change', render );
				//orbitControls.addEventListener( 'change', orbitControlsEventHandler );

				orbitControls.target.set(-2316265.9940429763, 2220230.3502845275, -5548271.348861104)
				orbitControls.upDirection.set(-0.3869936185981358, 0.3454706981476925, -0.8549186720885598)
				orbitControls.object.position.set(-2496230.512961196, 1756947.2154481024, -6045486.849424316)
				camera.up.set(-0.3869936185981358, 0.3454706981476925, -0.8549186720885598)







				transformControl = new TransformControls( camera, renderer.domElement );
				transformControl.addEventListener( 'change', render );
				transformControl.addEventListener( 'dragging-changed', function ( event ) {

					orbitControls.enabled = ! event.value;

				} );
				scene.add( transformControl );

				transformControl.addEventListener( 'objectChange', function () {

					updateSplineOutline();

				} );

				document.addEventListener( 'pointerdown', onPointerDown );
				document.addEventListener( 'pointerup', onPointerUp );
				document.addEventListener( 'pointermove', onPointerMove );
				window.addEventListener( 'resize', onWindowResize );

				/*******
				 * Curves
				 *********/

				for ( let i = 0; i < splinePointsLength; i ++ ) {

					addSplineObject( positions[ i ] );

				}

				positions.length = 0;

				for ( let i = 0; i < splinePointsLength; i ++ ) {

					positions.push( splineHandleObjects[ i ].position );

				}

				const geometry = new THREE.BufferGeometry();
				geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( ARC_SEGMENTS * 3 ), 3 ) );

				let curve = new THREE.CatmullRomSuperCurve3( positions );
				console.log('CURVE WORKED')
				curve.curveType = 'catmullrom';
				curve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {
					color: 0xff0000,
					opacity: 0.35
				} ) );
				curve.mesh.castShadow = true;
				splines.uniform = curve;

				curve = new THREE.CatmullRomSuperCurve3( positions );
				console.log('CURVE WORKED')
				curve.curveType = 'centripetal';
				curve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {
					color: 0x00ff00,
					opacity: 0.35
				} ) );
				curve.mesh.castShadow = true;
				splines.centripetal = curve;

				curve = new THREE.CatmullRomSuperCurve3( positions );
				curve.curveType = 'chordal';
				curve.mesh = new THREE.Line( geometry.clone(), new THREE.LineBasicMaterial( {
					color: 0x0000ff,
					opacity: 0.35
				} ) );
				curve.mesh.castShadow = true;
				splines.chordal = curve;

				for ( const k in splines ) {

					const spline = splines[ k ];
					scene.add( spline.mesh );

				}
				const sceneCenter = new THREE.Vector3(-2316265, 2220030, -5548271)
				load( [ new THREE.Vector3( 28900, 45200, 5600 ).add(sceneCenter),
					new THREE.Vector3( - 5300, 17100, -1400 ).add(sceneCenter),
					new THREE.Vector3( - 9100, 17600, -600 ).add(sceneCenter),
					new THREE.Vector3( - 38300, 49100, 4700 ).add(sceneCenter) ] );

				render();

			}


			// *****************************************************************
			// *****************************************************************
			// Animation Section
			// *****************************************************************
			// *****************************************************************


			let intersectionPoint = new THREE.Vector3
			let targetPoint = new THREE.Vector3
			let orbitControlsTargetPoint = new THREE.Vector3(0, 0, 0)
			let orbitControlsTargetUpVector = new THREE.Vector3(0, 1, 0)
			let trackingPoint = null  // This is the location of the object which was under the sprite when user last pressed the 'P' key  
			let lastTrackingPoint = null
			let orbitControlsEarthRingLerpFactor = 1 // When 1, this indicates no tweening is in progress
			let orbitControlsNewMaxPolarAngle = Math.PI
			let animateZoomingIn = false
			let animateZoomingOut = false
			let timeSinceStart = 0
			let orbitControlsUpVector = new THREE.Vector3(0, 1, 0)

			function animate() {
				renderer.setAnimationLoop( renderFrame )
			}

			function renderFrame() {
				const delta = clock.getDelta()
				timeSinceStart += delta
				TWEEN.update(timeSinceStart*1000)

				if (orbitControlsEarthRingLerpFactor!=1) {
					//console.log("Lerping...")
					orbitControlsEarthRingLerpFactor = tram.clamp(orbitControlsEarthRingLerpFactor + orbitControlsEarthRingLerpSpeed, 0, 1)
					const previousEnabled = orbitControls.enabled
					orbitControls.enabled = false
					orbitControls.target.lerpVectors(previousTargetPoint, orbitControlsTargetPoint, orbitControlsEarthRingLerpFactor)
					const upVector = new THREE.Vector3()
					upVector.lerpVectors(previousUpVector, orbitControlsTargetUpVector, orbitControlsEarthRingLerpFactor).normalize()
					camera.up.copy(upVector)
					orbitControls.upDirection.copy(upVector)
					upVector.lerpVectors(previousUpVector, orbitControlsTargetUpVector, orbitControlsEarthRingLerpFactor).normalize()
					camera.up.copy(upVector)
					orbitControls.upDirection.copy(upVector)
					orbitControls.screenSpacePanning = false
					orbitControls.enabled = previousEnabled
					orbitControls.update()
				}
				else {
					orbitControls.maxPolarAngle = orbitControlsNewMaxPolarAngle
					// const offTarget = orbitControls.target.clone().sub(orbitControlsTargetPoint).length()
					// console.log(offTarget)
					// if ((offTarget>100) && (offTarget<10000) && (orbitControlsTargetPoint.length()>radiusOfPlanet)) {
					//   orbitControls.target.lerp(orbitControlsTargetPoint, 0.02)
					//   console.log("pulling towards last target")
					// }
				}

				if (trackingPoint) {
					if (lastTrackingPoint) {
						const offset = trackingPoint.clone().sub(lastTrackingPoint)
						orbitControls.target.add(offset)
						orbitControls.object.position.add(offset)
					}
					lastTrackingPoint = trackingPoint.clone()
				}

				if (animateZoomingIn || animateZoomingOut) {
					var offset = new THREE.Vector3
					offset.copy( orbitControls.object.position ).sub( orbitControls.target )
					if (animateZoomingIn) {
						offset.multiplyScalar(1 - 10**logZoomRate)
					} else if (animateZoomingOut) {
						offset.multiplyScalar(1 + 10**logZoomRate)
					}
					orbitControls.object.position.copy( orbitControls.target ).add( offset )
				}
				orbitControls.update()

			}

			function gimbalMath() {
				// "Gimbal" code for the tetheredRingRefCoordSys    
				const ringCenterLatitude = -19.2
				const ringCenterLongitude = 186.3
				const v1 = new THREE.Vector3(0, 1, 0)
				const v2 = new THREE.Vector3().setFromSphericalCoords(
					1,
					Math.PI/2 - ringCenterLatitude,
					ringCenterLongitude,
				)
				ringToPlanetRotation.setFromUnitVectors(v1, v2)
				tetheredRingRefCoordSys.setRotationFromQuaternion(ringToPlanetRotation)
				tetheredRingRefCoordSys.updateMatrixWorld(true)
			}

			function orbitControlsEventHandler() {
				recomputeNearFarClippingPlanes()
			}

			function recomputeNearFarClippingPlanes() {
				// Calculate the distance to the nearest object - for this we will use the sphere encompassing the Earth and it's stratosphere
				// Multiply that by the cosine of the camera's fulstrum angle
				// Note: Assumes the planet is centered on the origin!!!
				camera.near = Math.max(10, camera.position.length() - (radiusOfPlanet+100)) * Math.cos(camera.getEffectiveFOV()*Math.PI/180)
				// Hack
				//camera.near = 0.1

				// camera.near = Math.max(10, camera.position.distanceTo(planetMeshes[0].position) - (radiusOfPlanet+dParamWithUnits['ringFinalAltitude'].value+extraDistanceForCamera)) * Math.cos(camera.getEffectiveFOV()*Math.PI/180)
				// Far calculation: Use the pythagorean theorm to compute distance to the Earth's horizon,
				// then add the distrance from there to the edge of the sphere that represents the atmosphere,
				// then pad this sum by a factor of 1.5
				const d1Squared = camera.position.length()**2 - radiusOfPlanet**2
				//const d1Squared = camera.position.distanceTo(planetMeshes[0].position)**2 - radiusOfPlanet**2
				const d2Squared = (radiusOfPlanet*1.1)**2 - radiusOfPlanet**2
				let d1, d2
				if (d1Squared>0) {
					d1 = Math.sqrt(d1Squared)
				}
				else {
					d1 = 0
				}
				if (d2Squared>0) {
					d2 = Math.sqrt(d2Squared)
				}
				else {
					d2 = 0
				}
				camera.far = Math.max(camera.near*16384, (d1 + d2) * 1.5)

				//console.log(camera.near, camera.near*16384, (d1+d2)*1.5, camera.far, 2)
				camera.updateProjectionMatrix()
				nearClippingPlane = camera.near
				farClippingPlane = camera.far
			}

			function onKeyDown( event ) {
				// Object.entries(guidParamWithUnits).forEach(([k, v]) => {
				//   v.value = guidParam[k]
				// })
				const RaiseLowerMode = true

				switch ( event.keyCode ) {
					case 79: /*O*/
						orbitControls.target.set(0, 0, 0)
						orbitControls.rotateSpeed = 1
						setOrbitControlsTargetUpVector()
						orbitControls.maxPolarAngle = Math.PI
						orbitControlsNewMaxPolarAngle = Math.PI
						//camera.up.set(0, 1, 0)
						break;
					case 73: /*I*/
						orbitControls.target = new THREE.Vector3(0, 1, 0).applyQuaternion(ringToPlanetRotation).multiplyScalar(crv.y0)
						orbitControls.rotateSpeed = 1
						setOrbitControlsTargetUpVector()
						orbitControls.maxPolarAngle = Math.PI
						orbitControlsNewMaxPolarAngle = Math.PI
						//camera.up.set(0, 1, 0)
						break;
					case 80: /*P*/
						recenterScene();
						break;
					case 81: /*Q*/
						orbitControls.autoRotate ^= true
						orbitControls.rotateSpeed = dParamWithUnits['orbitControlsRotateSpeed'].value
						break;
					case 88: /*X*/
						animateZoomingIn = false
						animateZoomingOut = !animateZoomingOut
						break;
					case 90: /*Z*/
						animateZoomingIn = !animateZoomingIn
						animateZoomingOut = false
						break;
				}
			}

			function onDoubleClick() {
				recenterScene();
			}

			function recenterScene() {
				raycaster.setFromCamera(mouse, camera)
				let planetIntersects = []
				planetMeshes.traverse(child => {
					if (child.type=='Mesh') {
						planetIntersects.push.apply(planetIntersects, raycaster.intersectObject(child))
					}
				})
				// let tubeIntersects = []
				// if (dParamWithUnits['showTransitSystem'].value || dParamWithUnits['showMassDriverTube'].value || dParamWithUnits['showEvacuatedTube'].value || dParamWithUnits['showLaunchVehicle'].value) {
				// 	planetCoordSys.children.forEach(mesh => {
				// 	//console.log(mesh.name)
				// 	if ((mesh.name==='massDriverTube') || (mesh.name==='evacuatedTube') || (mesh.name==='launchVehicle')) {
				// 		tubeIntersects.push.apply(tubeIntersects, raycaster.intersectObject(mesh))
				// 	}
				// 	})
				// 	tetheredRingRefCoordSys.children.forEach(mesh => {
				// 	if (mesh.name==='transitTube') {
				// 		tubeIntersects.push.apply(tubeIntersects, raycaster.intersectObject(mesh))
				// 	}
				// 	})
				// }
				// if (tubeIntersects.length>0) {
				// 	tubeIntersects.forEach(intersect => {
				// 	if (intersect.object.parent.name=='launchVehicle') {
				// 		trackingPoint = intersect.object.parent.position
				// 	}
				// 	})
				// 	if (trackingPoint) {
				// 	trackingPointMarkerMesh.position.copy(trackingPoint)
				// 	trackingPointMarkerMesh.visible = false
				// 	}
				// 	intersectionPoint = tubeIntersects[0].point
				// 	targetPoint = intersectionPoint
				// 	extraDistanceForCamera = 100
				// 	orbitControls.rotateSpeed = 0.9
				// }
				// else 
				if (planetIntersects.length>0) {
					intersectionPoint = planetIntersects[0].point
					// Because we want to orbit around a point aslightly above the surface
					const verticalOffset = 100 // m
					targetPoint = intersectionPoint.multiplyScalar((radiusOfPlanet + verticalOffset)/radiusOfPlanet)
				}
				if ((planetIntersects.length>0) || (tubeIntersects.length>0)) {
					orbitControlsTargetPoint.copy(targetPoint.clone())
					setOrbitControlsTargetUpVector()
					new TWEEN.Tween(orbitControls.target)
					.to(orbitControlsTargetPoint, 1000)
					.easing(TWEEN.Easing.Cubic.InOut)
					.start(timeSinceStart*1000)
					new TWEEN.Tween(orbitControls.upDirection)
					.to(orbitControlsTargetUpVector, 1000)
					.easing(TWEEN.Easing.Cubic.InOut)
					.start(timeSinceStart*1000)
					new TWEEN.Tween(camera.up)
					.to(orbitControlsTargetUpVector, 1000)
					.easing(TWEEN.Easing.Cubic.InOut)
					.start(timeSinceStart*1000)

					camera.up.copy(orbitControlsUpVector.clone())
					orbitControls.upDirection.copy(orbitControlsUpVector.clone())
				}

			}

			function setOrbitControlsTargetUpVector() {
				planetCoordSys.updateWorldMatrix(true)
				tetheredRingRefCoordSys.updateMatrixWorld(true)
				orbitControlsTargetUpVector = planetCoordSys.worldToLocal(orbitControlsTargetPoint.clone()).normalize()
			}



			function addSplineObject( position ) {

				const splineHandleMaterial = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } );
				const splineHandleMesh = new THREE.Mesh( splineHandleGeometry, splineHandleMaterial );

				if ( position ) {

					splineHandleMesh.position.copy( position );

				} else {

					splineHandleMesh.position.x = Math.random() * 1000 - 500;
					splineHandleMesh.position.y = Math.random() * 600;
					splineHandleMesh.position.z = Math.random() * 800 - 400;

				}

				splineHandleMesh.castShadow = true;
				splineHandleMesh.receiveShadow = true;
				splineHandleMesh.name = 'splineHandle' + splineHandleObjects.length
				scene.add( splineHandleMesh );
				splineHandleObjects.push( splineHandleMesh );
				return splineHandleMesh;

			}

			function addPoint() {

				splinePointsLength ++;

				positions.push( addSplineObject().position );

				updateSplineOutline();

				render();

			}

			function removePoint() {

				if ( splinePointsLength <= 4 ) {

					return;

				}

				const point = splineHandleObjects.pop();
				splinePointsLength --;
				positions.pop();

				if ( transformControl.object === point ) transformControl.detach();
				scene.remove( point );

				updateSplineOutline();

				render();

			}

			function updateSplineOutline() {

				for ( const k in splines ) {

					const spline = splines[ k ];

					const splineMesh = spline.mesh;
					const position = splineMesh.geometry.attributes.position;

					for ( let i = 0; i < ARC_SEGMENTS; i ++ ) {

						const t = i / ( ARC_SEGMENTS - 1 );
						spline.getPoint( t, point );
						position.setXYZ( i, point.x, point.y, point.z );

					}

					position.needsUpdate = true;

				}

			}

			function exportSpline() {

				const strplace = [];

				for ( let i = 0; i < splinePointsLength; i ++ ) {

					const p = splineHandleObjects[ i ].position;
					strplace.push( `new THREE.Vector3(${p.x}, ${p.y}, ${p.z})` );

				}

				console.log( strplace.join( ',\n' ) );
				const code = '[' + ( strplace.join( ',\n\t' ) ) + ']';
				prompt( 'copy and paste code', code );

			}

			function load( new_positions ) {

				while ( new_positions.length > positions.length ) {

					addPoint();

				}

				while ( new_positions.length < positions.length ) {

					removePoint();

				}

				for ( let i = 0; i < positions.length; i ++ ) {

					positions[ i ].copy( new_positions[ i ] );

				}

				updateSplineOutline();

			}

			function render() {

				splines.uniform.mesh.visible = params.uniform;
				splines.centripetal.mesh.visible = params.centripetal;
				splines.chordal.mesh.visible = params.chordal;
				renderer.render( scene, camera );

			}

			function onPointerDown( event ) {

				onDownPosition.x = event.clientX;
				onDownPosition.y = event.clientY;

			}

			function onPointerUp( event ) {

				onUpPosition.x = event.clientX;
				onUpPosition.y = event.clientY;

				if (transformControl.object) {
					transformControl.object.rotation.set(.5, .5, .5)
				}

				if ( onDownPosition.distanceTo( onUpPosition ) === 0 ) {
					
					// Set the orientation of the handleCube to align it with the surface of the planet
					// console.log(transformControl.object.position)
					transformControl.detach();
					render();

				}

			}

			function onPointerMove( event ) {

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObjects( splineHandleObjects, false );

				if ( intersects.length > 0 ) {

					const object = intersects[ 0 ].object;
					console.log('intersected')

					if ( (transformControl.object === undefined) || (object.name !== transformControl.object.name) ) {

						transformControl.attach( object );

					}
					transformControl.visible = true
					//transformControl.rotateX(0.1)

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

		</script>

	</body>
</html>
